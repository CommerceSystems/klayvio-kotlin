/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.GetAccounts4XXResponse
import org.openapitools.client.models.GetImportErrorResponseCollection
import org.openapitools.client.models.GetListResponseCollection
import org.openapitools.client.models.GetProfileImportJobListRelationshipsResponseCollection
import org.openapitools.client.models.GetProfileImportJobProfileRelationshipsResponseCollection
import org.openapitools.client.models.GetProfileImportJobResponseCollectionCompoundDocument
import org.openapitools.client.models.GetProfileImportJobResponseCompoundDocument
import org.openapitools.client.models.GetProfileListRelationshipsResponseCollection
import org.openapitools.client.models.GetProfileResponseCollection
import org.openapitools.client.models.GetProfileResponseCollectionCompoundDocument
import org.openapitools.client.models.GetProfileResponseCompoundDocument
import org.openapitools.client.models.GetProfileSegmentRelationshipsResponseCollection
import org.openapitools.client.models.GetSegmentResponseCollection
import org.openapitools.client.models.PatchProfileResponse
import org.openapitools.client.models.PostProfileImportJobResponse
import org.openapitools.client.models.PostProfileMergeResponse
import org.openapitools.client.models.PostProfileResponse
import org.openapitools.client.models.ProfileCreateQuery
import org.openapitools.client.models.ProfileImportJobCreateQuery
import org.openapitools.client.models.ProfileMergeQuery
import org.openapitools.client.models.ProfilePartialUpdateQuery
import org.openapitools.client.models.ProfileUpsertQuery
import org.openapitools.client.models.PushTokenCreateQuery
import org.openapitools.client.models.SubscriptionCreateJobCreateQuery
import org.openapitools.client.models.SubscriptionDeleteJobCreateQuery
import org.openapitools.client.models.SuppressionCreateJobCreateQuery
import org.openapitools.client.models.SuppressionDeleteJobCreateQuery

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ProfilesApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://a.klaviyo.com")
        }
    }

    /**
     * Create or Update Profile
     * Given a set of profile attributes and optionally an ID, create or update a profile.  Returns 201 if a new profile was created, 200 if an existing profile was updated.  Note that setting a field to &#x60;null&#x60; will clear out the field, whereas not including a field in your request will leave it unchanged.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileUpsertQuery 
     * @return PostProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createOrUpdateProfile(revision: kotlin.String = "2024-07-15", profileUpsertQuery: ProfileUpsertQuery) : PostProfileResponse {
        val localVarResponse = createOrUpdateProfileWithHttpInfo(revision = revision, profileUpsertQuery = profileUpsertQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create or Update Profile
     * Given a set of profile attributes and optionally an ID, create or update a profile.  Returns 201 if a new profile was created, 200 if an existing profile was updated.  Note that setting a field to &#x60;null&#x60; will clear out the field, whereas not including a field in your request will leave it unchanged.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileUpsertQuery 
     * @return ApiResponse<PostProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createOrUpdateProfileWithHttpInfo(revision: kotlin.String, profileUpsertQuery: ProfileUpsertQuery) : ApiResponse<PostProfileResponse?> {
        val localVariableConfig = createOrUpdateProfileRequestConfig(revision = revision, profileUpsertQuery = profileUpsertQuery)

        return request<ProfileUpsertQuery, PostProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createOrUpdateProfile
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileUpsertQuery 
     * @return RequestConfig
     */
    fun createOrUpdateProfileRequestConfig(revision: kotlin.String, profileUpsertQuery: ProfileUpsertQuery) : RequestConfig<ProfileUpsertQuery> {
        val localVariableBody = profileUpsertQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/profile-import/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Profile
     * Create a new profile.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileCreateQuery 
     * @return PostProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createProfile(revision: kotlin.String = "2024-07-15", profileCreateQuery: ProfileCreateQuery) : PostProfileResponse {
        val localVarResponse = createProfileWithHttpInfo(revision = revision, profileCreateQuery = profileCreateQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Profile
     * Create a new profile.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileCreateQuery 
     * @return ApiResponse<PostProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createProfileWithHttpInfo(revision: kotlin.String, profileCreateQuery: ProfileCreateQuery) : ApiResponse<PostProfileResponse?> {
        val localVariableConfig = createProfileRequestConfig(revision = revision, profileCreateQuery = profileCreateQuery)

        return request<ProfileCreateQuery, PostProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createProfile
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileCreateQuery 
     * @return RequestConfig
     */
    fun createProfileRequestConfig(revision: kotlin.String, profileCreateQuery: ProfileCreateQuery) : RequestConfig<ProfileCreateQuery> {
        val localVariableBody = profileCreateQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/profiles/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create or Update Push Token
     * Create or update a push token.  This endpoint can be used to migrate push tokens from another platform to Klaviyo. Please use our mobile SDKs ([iOS](https://github.com/klaviyo/klaviyo-swift-sdk) and [Android](https://github.com/klaviyo/klaviyo-android-sdk)) to create push tokens from users&#39; devices.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60; &#x60;push-tokens:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param pushTokenCreateQuery 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPushToken(revision: kotlin.String = "2024-07-15", pushTokenCreateQuery: PushTokenCreateQuery) : Unit {
        val localVarResponse = createPushTokenWithHttpInfo(revision = revision, pushTokenCreateQuery = pushTokenCreateQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create or Update Push Token
     * Create or update a push token.  This endpoint can be used to migrate push tokens from another platform to Klaviyo. Please use our mobile SDKs ([iOS](https://github.com/klaviyo/klaviyo-swift-sdk) and [Android](https://github.com/klaviyo/klaviyo-android-sdk)) to create push tokens from users&#39; devices.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60; &#x60;push-tokens:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param pushTokenCreateQuery 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun createPushTokenWithHttpInfo(revision: kotlin.String, pushTokenCreateQuery: PushTokenCreateQuery) : ApiResponse<Unit?> {
        val localVariableConfig = createPushTokenRequestConfig(revision = revision, pushTokenCreateQuery = pushTokenCreateQuery)

        return request<PushTokenCreateQuery, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPushToken
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param pushTokenCreateQuery 
     * @return RequestConfig
     */
    fun createPushTokenRequestConfig(revision: kotlin.String, pushTokenCreateQuery: PushTokenCreateQuery) : RequestConfig<PushTokenCreateQuery> {
        val localVariableBody = pushTokenCreateQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/push-tokens/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsList
     */
     enum class FieldsListGetBulkProfileImportJob(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "opt_in_process") opt_in_process("opt_in_process");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsProfileBulkImportJob
     */
     enum class FieldsProfileBulkImportJobGetBulkProfileImportJob(val value: kotlin.String) {
         @Json(name = "status") status("status"),
         @Json(name = "created_at") created_at("created_at"),
         @Json(name = "total_count") total_count("total_count"),
         @Json(name = "completed_count") completed_count("completed_count"),
         @Json(name = "failed_count") failed_count("failed_count"),
         @Json(name = "completed_at") completed_at("completed_at"),
         @Json(name = "expires_at") expires_at("expires_at"),
         @Json(name = "started_at") started_at("started_at");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter include
     */
     enum class IncludeGetBulkProfileImportJob(val value: kotlin.String) {
         @Json(name = "lists") lists("lists");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Bulk Profile Import Job
     * Get a bulk profile import job with the given job ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:read&#x60; &#x60;profiles:read&#x60;
     * @param jobId ID of the job to retrieve.
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfileBulkImportJob For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return GetProfileImportJobResponseCompoundDocument
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBulkProfileImportJob(jobId: kotlin.String, revision: kotlin.String = "2024-07-15", fieldsList: kotlin.collections.List<FieldsListGetBulkProfileImportJob>? = null, fieldsProfileBulkImportJob: kotlin.collections.List<FieldsProfileBulkImportJobGetBulkProfileImportJob>? = null, include: kotlin.collections.List<IncludeGetBulkProfileImportJob>? = null) : GetProfileImportJobResponseCompoundDocument {
        val localVarResponse = getBulkProfileImportJobWithHttpInfo(jobId = jobId, revision = revision, fieldsList = fieldsList, fieldsProfileBulkImportJob = fieldsProfileBulkImportJob, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileImportJobResponseCompoundDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Bulk Profile Import Job
     * Get a bulk profile import job with the given job ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:read&#x60; &#x60;profiles:read&#x60;
     * @param jobId ID of the job to retrieve.
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfileBulkImportJob For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return ApiResponse<GetProfileImportJobResponseCompoundDocument?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBulkProfileImportJobWithHttpInfo(jobId: kotlin.String, revision: kotlin.String, fieldsList: kotlin.collections.List<FieldsListGetBulkProfileImportJob>?, fieldsProfileBulkImportJob: kotlin.collections.List<FieldsProfileBulkImportJobGetBulkProfileImportJob>?, include: kotlin.collections.List<IncludeGetBulkProfileImportJob>?) : ApiResponse<GetProfileImportJobResponseCompoundDocument?> {
        val localVariableConfig = getBulkProfileImportJobRequestConfig(jobId = jobId, revision = revision, fieldsList = fieldsList, fieldsProfileBulkImportJob = fieldsProfileBulkImportJob, include = include)

        return request<Unit, GetProfileImportJobResponseCompoundDocument>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBulkProfileImportJob
     *
     * @param jobId ID of the job to retrieve.
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfileBulkImportJob For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return RequestConfig
     */
    fun getBulkProfileImportJobRequestConfig(jobId: kotlin.String, revision: kotlin.String, fieldsList: kotlin.collections.List<FieldsListGetBulkProfileImportJob>?, fieldsProfileBulkImportJob: kotlin.collections.List<FieldsProfileBulkImportJobGetBulkProfileImportJob>?, include: kotlin.collections.List<IncludeGetBulkProfileImportJob>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsList != null) {
                    put("fields[list]", toMultiValue(fieldsList.toList(), "csv"))
                }
                if (fieldsProfileBulkImportJob != null) {
                    put("fields[profile-bulk-import-job]", toMultiValue(fieldsProfileBulkImportJob.toList(), "csv"))
                }
                if (include != null) {
                    put("include", toMultiValue(include.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profile-bulk-import-jobs/{job_id}/".replace("{"+"job_id"+"}", encodeURIComponent(jobId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsImportError
     */
     enum class FieldsImportErrorGetBulkProfileImportJobImportErrors(val value: kotlin.String) {
         @Json(name = "code") code("code"),
         @Json(name = "title") title("title"),
         @Json(name = "detail") detail("detail"),
         @Json(name = "source") source("source"),
         @Json(name = "source.pointer") sourcePeriodPointer("source.pointer"),
         @Json(name = "original_payload") original_payload("original_payload");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Bulk Profile Import Job Errors
     * Get import errors for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsImportError For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return GetImportErrorResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBulkProfileImportJobImportErrors(id: kotlin.String, revision: kotlin.String = "2024-07-15", fieldsImportError: kotlin.collections.List<FieldsImportErrorGetBulkProfileImportJobImportErrors>? = null, pageCursor: kotlin.String? = null, pageSize: kotlin.Int? = 20) : GetImportErrorResponseCollection {
        val localVarResponse = getBulkProfileImportJobImportErrorsWithHttpInfo(id = id, revision = revision, fieldsImportError = fieldsImportError, pageCursor = pageCursor, pageSize = pageSize)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetImportErrorResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Bulk Profile Import Job Errors
     * Get import errors for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsImportError For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return ApiResponse<GetImportErrorResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBulkProfileImportJobImportErrorsWithHttpInfo(id: kotlin.String, revision: kotlin.String, fieldsImportError: kotlin.collections.List<FieldsImportErrorGetBulkProfileImportJobImportErrors>?, pageCursor: kotlin.String?, pageSize: kotlin.Int?) : ApiResponse<GetImportErrorResponseCollection?> {
        val localVariableConfig = getBulkProfileImportJobImportErrorsRequestConfig(id = id, revision = revision, fieldsImportError = fieldsImportError, pageCursor = pageCursor, pageSize = pageSize)

        return request<Unit, GetImportErrorResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBulkProfileImportJobImportErrors
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsImportError For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return RequestConfig
     */
    fun getBulkProfileImportJobImportErrorsRequestConfig(id: kotlin.String, revision: kotlin.String, fieldsImportError: kotlin.collections.List<FieldsImportErrorGetBulkProfileImportJobImportErrors>?, pageCursor: kotlin.String?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsImportError != null) {
                    put("fields[import-error]", toMultiValue(fieldsImportError.toList(), "csv"))
                }
                if (pageCursor != null) {
                    put("page[cursor]", listOf(pageCursor.toString()))
                }
                if (pageSize != null) {
                    put("page[size]", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profile-bulk-import-jobs/{id}/import-errors/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsList
     */
     enum class FieldsListGetBulkProfileImportJobLists(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "opt_in_process") opt_in_process("opt_in_process");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Bulk Profile Import Job Lists
     * Get list for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return GetListResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBulkProfileImportJobLists(id: kotlin.String, revision: kotlin.String = "2024-07-15", fieldsList: kotlin.collections.List<FieldsListGetBulkProfileImportJobLists>? = null) : GetListResponseCollection {
        val localVarResponse = getBulkProfileImportJobListsWithHttpInfo(id = id, revision = revision, fieldsList = fieldsList)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetListResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Bulk Profile Import Job Lists
     * Get list for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return ApiResponse<GetListResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBulkProfileImportJobListsWithHttpInfo(id: kotlin.String, revision: kotlin.String, fieldsList: kotlin.collections.List<FieldsListGetBulkProfileImportJobLists>?) : ApiResponse<GetListResponseCollection?> {
        val localVariableConfig = getBulkProfileImportJobListsRequestConfig(id = id, revision = revision, fieldsList = fieldsList)

        return request<Unit, GetListResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBulkProfileImportJobLists
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return RequestConfig
     */
    fun getBulkProfileImportJobListsRequestConfig(id: kotlin.String, revision: kotlin.String, fieldsList: kotlin.collections.List<FieldsListGetBulkProfileImportJobLists>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsList != null) {
                    put("fields[list]", toMultiValue(fieldsList.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profile-bulk-import-jobs/{id}/lists/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter additionalFieldsProfile
     */
     enum class AdditionalFieldsProfileGetBulkProfileImportJobProfiles(val value: kotlin.String) {
         @Json(name = "subscriptions") subscriptions("subscriptions"),
         @Json(name = "predictive_analytics") predictive_analytics("predictive_analytics");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsProfile
     */
     enum class FieldsProfileGetBulkProfileImportJobProfiles(val value: kotlin.String) {
         @Json(name = "email") email("email"),
         @Json(name = "phone_number") phone_number("phone_number"),
         @Json(name = "external_id") external_id("external_id"),
         @Json(name = "first_name") first_name("first_name"),
         @Json(name = "last_name") last_name("last_name"),
         @Json(name = "organization") organization("organization"),
         @Json(name = "locale") locale("locale"),
         @Json(name = "title") title("title"),
         @Json(name = "image") image("image"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "last_event_date") last_event_date("last_event_date"),
         @Json(name = "location") location("location"),
         @Json(name = "location.address1") locationPeriodAddress1("location.address1"),
         @Json(name = "location.address2") locationPeriodAddress2("location.address2"),
         @Json(name = "location.city") locationPeriodCity("location.city"),
         @Json(name = "location.country") locationPeriodCountry("location.country"),
         @Json(name = "location.latitude") locationPeriodLatitude("location.latitude"),
         @Json(name = "location.longitude") locationPeriodLongitude("location.longitude"),
         @Json(name = "location.region") locationPeriodRegion("location.region"),
         @Json(name = "location.zip") locationPeriodZip("location.zip"),
         @Json(name = "location.timezone") locationPeriodTimezone("location.timezone"),
         @Json(name = "location.ip") locationPeriodIp("location.ip"),
         @Json(name = "properties") properties("properties"),
         @Json(name = "subscriptions") subscriptions("subscriptions"),
         @Json(name = "subscriptions.email") subscriptionsPeriodEmail("subscriptions.email"),
         @Json(name = "subscriptions.email.marketing") subscriptionsPeriodEmailPeriodMarketing("subscriptions.email.marketing"),
         @Json(name = "subscriptions.email.marketing.can_receive_email_marketing") subscriptionsPeriodEmailPeriodMarketingPeriodCan_receive_email_marketing("subscriptions.email.marketing.can_receive_email_marketing"),
         @Json(name = "subscriptions.email.marketing.consent") subscriptionsPeriodEmailPeriodMarketingPeriodConsent("subscriptions.email.marketing.consent"),
         @Json(name = "subscriptions.email.marketing.consent_timestamp") subscriptionsPeriodEmailPeriodMarketingPeriodConsent_timestamp("subscriptions.email.marketing.consent_timestamp"),
         @Json(name = "subscriptions.email.marketing.last_updated") subscriptionsPeriodEmailPeriodMarketingPeriodLast_updated("subscriptions.email.marketing.last_updated"),
         @Json(name = "subscriptions.email.marketing.method") subscriptionsPeriodEmailPeriodMarketingPeriodMethod("subscriptions.email.marketing.method"),
         @Json(name = "subscriptions.email.marketing.method_detail") subscriptionsPeriodEmailPeriodMarketingPeriodMethod_detail("subscriptions.email.marketing.method_detail"),
         @Json(name = "subscriptions.email.marketing.custom_method_detail") subscriptionsPeriodEmailPeriodMarketingPeriodCustom_method_detail("subscriptions.email.marketing.custom_method_detail"),
         @Json(name = "subscriptions.email.marketing.double_optin") subscriptionsPeriodEmailPeriodMarketingPeriodDouble_optin("subscriptions.email.marketing.double_optin"),
         @Json(name = "subscriptions.email.marketing.suppression") subscriptionsPeriodEmailPeriodMarketingPeriodSuppression("subscriptions.email.marketing.suppression"),
         @Json(name = "subscriptions.email.marketing.list_suppressions") subscriptionsPeriodEmailPeriodMarketingPeriodList_suppressions("subscriptions.email.marketing.list_suppressions"),
         @Json(name = "subscriptions.sms") subscriptionsPeriodSms("subscriptions.sms"),
         @Json(name = "subscriptions.sms.marketing") subscriptionsPeriodSmsPeriodMarketing("subscriptions.sms.marketing"),
         @Json(name = "subscriptions.sms.marketing.can_receive_sms_marketing") subscriptionsPeriodSmsPeriodMarketingPeriodCan_receive_sms_marketing("subscriptions.sms.marketing.can_receive_sms_marketing"),
         @Json(name = "subscriptions.sms.marketing.consent") subscriptionsPeriodSmsPeriodMarketingPeriodConsent("subscriptions.sms.marketing.consent"),
         @Json(name = "subscriptions.sms.marketing.consent_timestamp") subscriptionsPeriodSmsPeriodMarketingPeriodConsent_timestamp("subscriptions.sms.marketing.consent_timestamp"),
         @Json(name = "subscriptions.sms.marketing.method") subscriptionsPeriodSmsPeriodMarketingPeriodMethod("subscriptions.sms.marketing.method"),
         @Json(name = "subscriptions.sms.marketing.method_detail") subscriptionsPeriodSmsPeriodMarketingPeriodMethod_detail("subscriptions.sms.marketing.method_detail"),
         @Json(name = "subscriptions.sms.marketing.last_updated") subscriptionsPeriodSmsPeriodMarketingPeriodLast_updated("subscriptions.sms.marketing.last_updated"),
         @Json(name = "subscriptions.mobile_push") subscriptionsPeriodMobile_push("subscriptions.mobile_push"),
         @Json(name = "subscriptions.mobile_push.marketing") subscriptionsPeriodMobile_pushPeriodMarketing("subscriptions.mobile_push.marketing"),
         @Json(name = "subscriptions.mobile_push.marketing.can_receive_push_marketing") subscriptionsPeriodMobile_pushPeriodMarketingPeriodCan_receive_push_marketing("subscriptions.mobile_push.marketing.can_receive_push_marketing"),
         @Json(name = "subscriptions.mobile_push.marketing.consent") subscriptionsPeriodMobile_pushPeriodMarketingPeriodConsent("subscriptions.mobile_push.marketing.consent"),
         @Json(name = "subscriptions.mobile_push.marketing.consent_timestamp") subscriptionsPeriodMobile_pushPeriodMarketingPeriodConsent_timestamp("subscriptions.mobile_push.marketing.consent_timestamp"),
         @Json(name = "predictive_analytics") predictive_analytics("predictive_analytics"),
         @Json(name = "predictive_analytics.historic_clv") predictive_analyticsPeriodHistoric_clv("predictive_analytics.historic_clv"),
         @Json(name = "predictive_analytics.predicted_clv") predictive_analyticsPeriodPredicted_clv("predictive_analytics.predicted_clv"),
         @Json(name = "predictive_analytics.total_clv") predictive_analyticsPeriodTotal_clv("predictive_analytics.total_clv"),
         @Json(name = "predictive_analytics.historic_number_of_orders") predictive_analyticsPeriodHistoric_number_of_orders("predictive_analytics.historic_number_of_orders"),
         @Json(name = "predictive_analytics.predicted_number_of_orders") predictive_analyticsPeriodPredicted_number_of_orders("predictive_analytics.predicted_number_of_orders"),
         @Json(name = "predictive_analytics.average_days_between_orders") predictive_analyticsPeriodAverage_days_between_orders("predictive_analytics.average_days_between_orders"),
         @Json(name = "predictive_analytics.average_order_value") predictive_analyticsPeriodAverage_order_value("predictive_analytics.average_order_value"),
         @Json(name = "predictive_analytics.churn_probability") predictive_analyticsPeriodChurn_probability("predictive_analytics.churn_probability"),
         @Json(name = "predictive_analytics.expected_date_of_next_order") predictive_analyticsPeriodExpected_date_of_next_order("predictive_analytics.expected_date_of_next_order");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Bulk Profile Import Job Profiles
     * Get profiles for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return GetProfileResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBulkProfileImportJobProfiles(id: kotlin.String, revision: kotlin.String = "2024-07-15", additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetBulkProfileImportJobProfiles>? = null, fieldsProfile: kotlin.collections.List<FieldsProfileGetBulkProfileImportJobProfiles>? = null, pageCursor: kotlin.String? = null, pageSize: kotlin.Int? = 20) : GetProfileResponseCollection {
        val localVarResponse = getBulkProfileImportJobProfilesWithHttpInfo(id = id, revision = revision, additionalFieldsProfile = additionalFieldsProfile, fieldsProfile = fieldsProfile, pageCursor = pageCursor, pageSize = pageSize)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Bulk Profile Import Job Profiles
     * Get profiles for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return ApiResponse<GetProfileResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBulkProfileImportJobProfilesWithHttpInfo(id: kotlin.String, revision: kotlin.String, additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetBulkProfileImportJobProfiles>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetBulkProfileImportJobProfiles>?, pageCursor: kotlin.String?, pageSize: kotlin.Int?) : ApiResponse<GetProfileResponseCollection?> {
        val localVariableConfig = getBulkProfileImportJobProfilesRequestConfig(id = id, revision = revision, additionalFieldsProfile = additionalFieldsProfile, fieldsProfile = fieldsProfile, pageCursor = pageCursor, pageSize = pageSize)

        return request<Unit, GetProfileResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBulkProfileImportJobProfiles
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return RequestConfig
     */
    fun getBulkProfileImportJobProfilesRequestConfig(id: kotlin.String, revision: kotlin.String, additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetBulkProfileImportJobProfiles>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetBulkProfileImportJobProfiles>?, pageCursor: kotlin.String?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (additionalFieldsProfile != null) {
                    put("additional-fields[profile]", toMultiValue(additionalFieldsProfile.toList(), "csv"))
                }
                if (fieldsProfile != null) {
                    put("fields[profile]", toMultiValue(fieldsProfile.toList(), "csv"))
                }
                if (pageCursor != null) {
                    put("page[cursor]", listOf(pageCursor.toString()))
                }
                if (pageSize != null) {
                    put("page[size]", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profile-bulk-import-jobs/{id}/profiles/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Bulk Profile Import Job Relationships Lists
     * Get list relationship for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return GetProfileImportJobListRelationshipsResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBulkProfileImportJobRelationshipsLists(id: kotlin.String, revision: kotlin.String = "2024-07-15") : GetProfileImportJobListRelationshipsResponseCollection {
        val localVarResponse = getBulkProfileImportJobRelationshipsListsWithHttpInfo(id = id, revision = revision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileImportJobListRelationshipsResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Bulk Profile Import Job Relationships Lists
     * Get list relationship for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return ApiResponse<GetProfileImportJobListRelationshipsResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBulkProfileImportJobRelationshipsListsWithHttpInfo(id: kotlin.String, revision: kotlin.String) : ApiResponse<GetProfileImportJobListRelationshipsResponseCollection?> {
        val localVariableConfig = getBulkProfileImportJobRelationshipsListsRequestConfig(id = id, revision = revision)

        return request<Unit, GetProfileImportJobListRelationshipsResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBulkProfileImportJobRelationshipsLists
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return RequestConfig
     */
    fun getBulkProfileImportJobRelationshipsListsRequestConfig(id: kotlin.String, revision: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profile-bulk-import-jobs/{id}/relationships/lists/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Bulk Profile Import Job Relationships Profiles
     * Get profile relationships for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return GetProfileImportJobProfileRelationshipsResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBulkProfileImportJobRelationshipsProfiles(id: kotlin.String, revision: kotlin.String = "2024-07-15", pageCursor: kotlin.String? = null, pageSize: kotlin.Int? = 20) : GetProfileImportJobProfileRelationshipsResponseCollection {
        val localVarResponse = getBulkProfileImportJobRelationshipsProfilesWithHttpInfo(id = id, revision = revision, pageCursor = pageCursor, pageSize = pageSize)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileImportJobProfileRelationshipsResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Bulk Profile Import Job Relationships Profiles
     * Get profile relationships for the bulk profile import job with the given ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return ApiResponse<GetProfileImportJobProfileRelationshipsResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBulkProfileImportJobRelationshipsProfilesWithHttpInfo(id: kotlin.String, revision: kotlin.String, pageCursor: kotlin.String?, pageSize: kotlin.Int?) : ApiResponse<GetProfileImportJobProfileRelationshipsResponseCollection?> {
        val localVariableConfig = getBulkProfileImportJobRelationshipsProfilesRequestConfig(id = id, revision = revision, pageCursor = pageCursor, pageSize = pageSize)

        return request<Unit, GetProfileImportJobProfileRelationshipsResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBulkProfileImportJobRelationshipsProfiles
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @return RequestConfig
     */
    fun getBulkProfileImportJobRelationshipsProfilesRequestConfig(id: kotlin.String, revision: kotlin.String, pageCursor: kotlin.String?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (pageCursor != null) {
                    put("page[cursor]", listOf(pageCursor.toString()))
                }
                if (pageSize != null) {
                    put("page[size]", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profile-bulk-import-jobs/{id}/relationships/profiles/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsProfileBulkImportJob
     */
     enum class FieldsProfileBulkImportJobGetBulkProfileImportJobs(val value: kotlin.String) {
         @Json(name = "status") status("status"),
         @Json(name = "created_at") created_at("created_at"),
         @Json(name = "total_count") total_count("total_count"),
         @Json(name = "completed_count") completed_count("completed_count"),
         @Json(name = "failed_count") failed_count("failed_count"),
         @Json(name = "completed_at") completed_at("completed_at"),
         @Json(name = "expires_at") expires_at("expires_at"),
         @Json(name = "started_at") started_at("started_at");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetBulkProfileImportJobs(val value: kotlin.String) {
         @Json(name = "created_at") created_at("created_at"),
         @Json(name = "-created_at") MinusCreated_at("-created_at");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Bulk Profile Import Jobs
     * Get all bulk profile import jobs.  Returns a maximum of 100 jobs per request.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:read&#x60; &#x60;profiles:read&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsProfileBulkImportJob For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;any&#x60;, &#x60;equals&#x60; (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return GetProfileImportJobResponseCollectionCompoundDocument
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBulkProfileImportJobs(revision: kotlin.String = "2024-07-15", fieldsProfileBulkImportJob: kotlin.collections.List<FieldsProfileBulkImportJobGetBulkProfileImportJobs>? = null, filter: kotlin.String? = null, pageCursor: kotlin.String? = null, pageSize: kotlin.Int? = 20, sort: SortGetBulkProfileImportJobs? = null) : GetProfileImportJobResponseCollectionCompoundDocument {
        val localVarResponse = getBulkProfileImportJobsWithHttpInfo(revision = revision, fieldsProfileBulkImportJob = fieldsProfileBulkImportJob, filter = filter, pageCursor = pageCursor, pageSize = pageSize, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileImportJobResponseCollectionCompoundDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Bulk Profile Import Jobs
     * Get all bulk profile import jobs.  Returns a maximum of 100 jobs per request.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:read&#x60; &#x60;profiles:read&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsProfileBulkImportJob For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;any&#x60;, &#x60;equals&#x60; (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return ApiResponse<GetProfileImportJobResponseCollectionCompoundDocument?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBulkProfileImportJobsWithHttpInfo(revision: kotlin.String, fieldsProfileBulkImportJob: kotlin.collections.List<FieldsProfileBulkImportJobGetBulkProfileImportJobs>?, filter: kotlin.String?, pageCursor: kotlin.String?, pageSize: kotlin.Int?, sort: SortGetBulkProfileImportJobs?) : ApiResponse<GetProfileImportJobResponseCollectionCompoundDocument?> {
        val localVariableConfig = getBulkProfileImportJobsRequestConfig(revision = revision, fieldsProfileBulkImportJob = fieldsProfileBulkImportJob, filter = filter, pageCursor = pageCursor, pageSize = pageSize, sort = sort)

        return request<Unit, GetProfileImportJobResponseCollectionCompoundDocument>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBulkProfileImportJobs
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsProfileBulkImportJob For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;status&#x60;: &#x60;any&#x60;, &#x60;equals&#x60; (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return RequestConfig
     */
    fun getBulkProfileImportJobsRequestConfig(revision: kotlin.String, fieldsProfileBulkImportJob: kotlin.collections.List<FieldsProfileBulkImportJobGetBulkProfileImportJobs>?, filter: kotlin.String?, pageCursor: kotlin.String?, pageSize: kotlin.Int?, sort: SortGetBulkProfileImportJobs?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsProfileBulkImportJob != null) {
                    put("fields[profile-bulk-import-job]", toMultiValue(fieldsProfileBulkImportJob.toList(), "csv"))
                }
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
                if (pageCursor != null) {
                    put("page[cursor]", listOf(pageCursor.toString()))
                }
                if (pageSize != null) {
                    put("page[size]", listOf(pageSize.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profile-bulk-import-jobs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter additionalFieldsProfile
     */
     enum class AdditionalFieldsProfileGetProfile(val value: kotlin.String) {
         @Json(name = "subscriptions") subscriptions("subscriptions"),
         @Json(name = "predictive_analytics") predictive_analytics("predictive_analytics");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsList
     */
     enum class FieldsListGetProfile(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "opt_in_process") opt_in_process("opt_in_process");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsProfile
     */
     enum class FieldsProfileGetProfile(val value: kotlin.String) {
         @Json(name = "email") email("email"),
         @Json(name = "phone_number") phone_number("phone_number"),
         @Json(name = "external_id") external_id("external_id"),
         @Json(name = "first_name") first_name("first_name"),
         @Json(name = "last_name") last_name("last_name"),
         @Json(name = "organization") organization("organization"),
         @Json(name = "locale") locale("locale"),
         @Json(name = "title") title("title"),
         @Json(name = "image") image("image"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "last_event_date") last_event_date("last_event_date"),
         @Json(name = "location") location("location"),
         @Json(name = "location.address1") locationPeriodAddress1("location.address1"),
         @Json(name = "location.address2") locationPeriodAddress2("location.address2"),
         @Json(name = "location.city") locationPeriodCity("location.city"),
         @Json(name = "location.country") locationPeriodCountry("location.country"),
         @Json(name = "location.latitude") locationPeriodLatitude("location.latitude"),
         @Json(name = "location.longitude") locationPeriodLongitude("location.longitude"),
         @Json(name = "location.region") locationPeriodRegion("location.region"),
         @Json(name = "location.zip") locationPeriodZip("location.zip"),
         @Json(name = "location.timezone") locationPeriodTimezone("location.timezone"),
         @Json(name = "location.ip") locationPeriodIp("location.ip"),
         @Json(name = "properties") properties("properties"),
         @Json(name = "subscriptions") subscriptions("subscriptions"),
         @Json(name = "subscriptions.email") subscriptionsPeriodEmail("subscriptions.email"),
         @Json(name = "subscriptions.email.marketing") subscriptionsPeriodEmailPeriodMarketing("subscriptions.email.marketing"),
         @Json(name = "subscriptions.email.marketing.can_receive_email_marketing") subscriptionsPeriodEmailPeriodMarketingPeriodCan_receive_email_marketing("subscriptions.email.marketing.can_receive_email_marketing"),
         @Json(name = "subscriptions.email.marketing.consent") subscriptionsPeriodEmailPeriodMarketingPeriodConsent("subscriptions.email.marketing.consent"),
         @Json(name = "subscriptions.email.marketing.consent_timestamp") subscriptionsPeriodEmailPeriodMarketingPeriodConsent_timestamp("subscriptions.email.marketing.consent_timestamp"),
         @Json(name = "subscriptions.email.marketing.last_updated") subscriptionsPeriodEmailPeriodMarketingPeriodLast_updated("subscriptions.email.marketing.last_updated"),
         @Json(name = "subscriptions.email.marketing.method") subscriptionsPeriodEmailPeriodMarketingPeriodMethod("subscriptions.email.marketing.method"),
         @Json(name = "subscriptions.email.marketing.method_detail") subscriptionsPeriodEmailPeriodMarketingPeriodMethod_detail("subscriptions.email.marketing.method_detail"),
         @Json(name = "subscriptions.email.marketing.custom_method_detail") subscriptionsPeriodEmailPeriodMarketingPeriodCustom_method_detail("subscriptions.email.marketing.custom_method_detail"),
         @Json(name = "subscriptions.email.marketing.double_optin") subscriptionsPeriodEmailPeriodMarketingPeriodDouble_optin("subscriptions.email.marketing.double_optin"),
         @Json(name = "subscriptions.email.marketing.suppression") subscriptionsPeriodEmailPeriodMarketingPeriodSuppression("subscriptions.email.marketing.suppression"),
         @Json(name = "subscriptions.email.marketing.list_suppressions") subscriptionsPeriodEmailPeriodMarketingPeriodList_suppressions("subscriptions.email.marketing.list_suppressions"),
         @Json(name = "subscriptions.sms") subscriptionsPeriodSms("subscriptions.sms"),
         @Json(name = "subscriptions.sms.marketing") subscriptionsPeriodSmsPeriodMarketing("subscriptions.sms.marketing"),
         @Json(name = "subscriptions.sms.marketing.can_receive_sms_marketing") subscriptionsPeriodSmsPeriodMarketingPeriodCan_receive_sms_marketing("subscriptions.sms.marketing.can_receive_sms_marketing"),
         @Json(name = "subscriptions.sms.marketing.consent") subscriptionsPeriodSmsPeriodMarketingPeriodConsent("subscriptions.sms.marketing.consent"),
         @Json(name = "subscriptions.sms.marketing.consent_timestamp") subscriptionsPeriodSmsPeriodMarketingPeriodConsent_timestamp("subscriptions.sms.marketing.consent_timestamp"),
         @Json(name = "subscriptions.sms.marketing.method") subscriptionsPeriodSmsPeriodMarketingPeriodMethod("subscriptions.sms.marketing.method"),
         @Json(name = "subscriptions.sms.marketing.method_detail") subscriptionsPeriodSmsPeriodMarketingPeriodMethod_detail("subscriptions.sms.marketing.method_detail"),
         @Json(name = "subscriptions.sms.marketing.last_updated") subscriptionsPeriodSmsPeriodMarketingPeriodLast_updated("subscriptions.sms.marketing.last_updated"),
         @Json(name = "subscriptions.mobile_push") subscriptionsPeriodMobile_push("subscriptions.mobile_push"),
         @Json(name = "subscriptions.mobile_push.marketing") subscriptionsPeriodMobile_pushPeriodMarketing("subscriptions.mobile_push.marketing"),
         @Json(name = "subscriptions.mobile_push.marketing.can_receive_push_marketing") subscriptionsPeriodMobile_pushPeriodMarketingPeriodCan_receive_push_marketing("subscriptions.mobile_push.marketing.can_receive_push_marketing"),
         @Json(name = "subscriptions.mobile_push.marketing.consent") subscriptionsPeriodMobile_pushPeriodMarketingPeriodConsent("subscriptions.mobile_push.marketing.consent"),
         @Json(name = "subscriptions.mobile_push.marketing.consent_timestamp") subscriptionsPeriodMobile_pushPeriodMarketingPeriodConsent_timestamp("subscriptions.mobile_push.marketing.consent_timestamp"),
         @Json(name = "predictive_analytics") predictive_analytics("predictive_analytics"),
         @Json(name = "predictive_analytics.historic_clv") predictive_analyticsPeriodHistoric_clv("predictive_analytics.historic_clv"),
         @Json(name = "predictive_analytics.predicted_clv") predictive_analyticsPeriodPredicted_clv("predictive_analytics.predicted_clv"),
         @Json(name = "predictive_analytics.total_clv") predictive_analyticsPeriodTotal_clv("predictive_analytics.total_clv"),
         @Json(name = "predictive_analytics.historic_number_of_orders") predictive_analyticsPeriodHistoric_number_of_orders("predictive_analytics.historic_number_of_orders"),
         @Json(name = "predictive_analytics.predicted_number_of_orders") predictive_analyticsPeriodPredicted_number_of_orders("predictive_analytics.predicted_number_of_orders"),
         @Json(name = "predictive_analytics.average_days_between_orders") predictive_analyticsPeriodAverage_days_between_orders("predictive_analytics.average_days_between_orders"),
         @Json(name = "predictive_analytics.average_order_value") predictive_analyticsPeriodAverage_order_value("predictive_analytics.average_order_value"),
         @Json(name = "predictive_analytics.churn_probability") predictive_analyticsPeriodChurn_probability("predictive_analytics.churn_probability"),
         @Json(name = "predictive_analytics.expected_date_of_next_order") predictive_analyticsPeriodExpected_date_of_next_order("predictive_analytics.expected_date_of_next_order");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsSegment
     */
     enum class FieldsSegmentGetProfile(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "definition") definition("definition"),
         @Json(name = "definition.condition_groups") definitionPeriodCondition_groups("definition.condition_groups"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "is_active") is_active("is_active"),
         @Json(name = "is_processing") is_processing("is_processing"),
         @Json(name = "is_starred") is_starred("is_starred");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter include
     */
     enum class IncludeGetProfile(val value: kotlin.String) {
         @Json(name = "lists") lists("lists"),
         @Json(name = "segments") segments("segments");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Profile
     * Get the profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsSegment For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return GetProfileResponseCompoundDocument
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfile(id: kotlin.String, revision: kotlin.String = "2024-07-15", additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetProfile>? = null, fieldsList: kotlin.collections.List<FieldsListGetProfile>? = null, fieldsProfile: kotlin.collections.List<FieldsProfileGetProfile>? = null, fieldsSegment: kotlin.collections.List<FieldsSegmentGetProfile>? = null, include: kotlin.collections.List<IncludeGetProfile>? = null) : GetProfileResponseCompoundDocument {
        val localVarResponse = getProfileWithHttpInfo(id = id, revision = revision, additionalFieldsProfile = additionalFieldsProfile, fieldsList = fieldsList, fieldsProfile = fieldsProfile, fieldsSegment = fieldsSegment, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileResponseCompoundDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Profile
     * Get the profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsSegment For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return ApiResponse<GetProfileResponseCompoundDocument?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfileWithHttpInfo(id: kotlin.String, revision: kotlin.String, additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetProfile>?, fieldsList: kotlin.collections.List<FieldsListGetProfile>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetProfile>?, fieldsSegment: kotlin.collections.List<FieldsSegmentGetProfile>?, include: kotlin.collections.List<IncludeGetProfile>?) : ApiResponse<GetProfileResponseCompoundDocument?> {
        val localVariableConfig = getProfileRequestConfig(id = id, revision = revision, additionalFieldsProfile = additionalFieldsProfile, fieldsList = fieldsList, fieldsProfile = fieldsProfile, fieldsSegment = fieldsSegment, include = include)

        return request<Unit, GetProfileResponseCompoundDocument>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfile
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsSegment For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return RequestConfig
     */
    fun getProfileRequestConfig(id: kotlin.String, revision: kotlin.String, additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetProfile>?, fieldsList: kotlin.collections.List<FieldsListGetProfile>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetProfile>?, fieldsSegment: kotlin.collections.List<FieldsSegmentGetProfile>?, include: kotlin.collections.List<IncludeGetProfile>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (additionalFieldsProfile != null) {
                    put("additional-fields[profile]", toMultiValue(additionalFieldsProfile.toList(), "csv"))
                }
                if (fieldsList != null) {
                    put("fields[list]", toMultiValue(fieldsList.toList(), "csv"))
                }
                if (fieldsProfile != null) {
                    put("fields[profile]", toMultiValue(fieldsProfile.toList(), "csv"))
                }
                if (fieldsSegment != null) {
                    put("fields[segment]", toMultiValue(fieldsSegment.toList(), "csv"))
                }
                if (include != null) {
                    put("include", toMultiValue(include.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profiles/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsList
     */
     enum class FieldsListGetProfileLists(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "opt_in_process") opt_in_process("opt_in_process");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Profile Lists
     * Get list memberships for a profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;3/s&#x60;&lt;br&gt;Steady: &#x60;60/m&#x60;  **Scopes:** &#x60;lists:read&#x60; &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return GetListResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfileLists(id: kotlin.String, revision: kotlin.String = "2024-07-15", fieldsList: kotlin.collections.List<FieldsListGetProfileLists>? = null) : GetListResponseCollection {
        val localVarResponse = getProfileListsWithHttpInfo(id = id, revision = revision, fieldsList = fieldsList)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetListResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Profile Lists
     * Get list memberships for a profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;3/s&#x60;&lt;br&gt;Steady: &#x60;60/m&#x60;  **Scopes:** &#x60;lists:read&#x60; &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return ApiResponse<GetListResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfileListsWithHttpInfo(id: kotlin.String, revision: kotlin.String, fieldsList: kotlin.collections.List<FieldsListGetProfileLists>?) : ApiResponse<GetListResponseCollection?> {
        val localVariableConfig = getProfileListsRequestConfig(id = id, revision = revision, fieldsList = fieldsList)

        return request<Unit, GetListResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfileLists
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsList For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return RequestConfig
     */
    fun getProfileListsRequestConfig(id: kotlin.String, revision: kotlin.String, fieldsList: kotlin.collections.List<FieldsListGetProfileLists>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsList != null) {
                    put("fields[list]", toMultiValue(fieldsList.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profiles/{id}/lists/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Profile Relationships Lists
     * Get list memberships for a profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;3/s&#x60;&lt;br&gt;Steady: &#x60;60/m&#x60;  **Scopes:** &#x60;lists:read&#x60; &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return GetProfileListRelationshipsResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfileRelationshipsLists(id: kotlin.String, revision: kotlin.String = "2024-07-15") : GetProfileListRelationshipsResponseCollection {
        val localVarResponse = getProfileRelationshipsListsWithHttpInfo(id = id, revision = revision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileListRelationshipsResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Profile Relationships Lists
     * Get list memberships for a profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;3/s&#x60;&lt;br&gt;Steady: &#x60;60/m&#x60;  **Scopes:** &#x60;lists:read&#x60; &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return ApiResponse<GetProfileListRelationshipsResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfileRelationshipsListsWithHttpInfo(id: kotlin.String, revision: kotlin.String) : ApiResponse<GetProfileListRelationshipsResponseCollection?> {
        val localVariableConfig = getProfileRelationshipsListsRequestConfig(id = id, revision = revision)

        return request<Unit, GetProfileListRelationshipsResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfileRelationshipsLists
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return RequestConfig
     */
    fun getProfileRelationshipsListsRequestConfig(id: kotlin.String, revision: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profiles/{id}/relationships/lists/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Profile Relationships Segments
     * Get segment membership relationships for a profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;3/s&#x60;&lt;br&gt;Steady: &#x60;60/m&#x60;  **Scopes:** &#x60;profiles:read&#x60; &#x60;segments:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return GetProfileSegmentRelationshipsResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfileRelationshipsSegments(id: kotlin.String, revision: kotlin.String = "2024-07-15") : GetProfileSegmentRelationshipsResponseCollection {
        val localVarResponse = getProfileRelationshipsSegmentsWithHttpInfo(id = id, revision = revision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileSegmentRelationshipsResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Profile Relationships Segments
     * Get segment membership relationships for a profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;3/s&#x60;&lt;br&gt;Steady: &#x60;60/m&#x60;  **Scopes:** &#x60;profiles:read&#x60; &#x60;segments:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return ApiResponse<GetProfileSegmentRelationshipsResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfileRelationshipsSegmentsWithHttpInfo(id: kotlin.String, revision: kotlin.String) : ApiResponse<GetProfileSegmentRelationshipsResponseCollection?> {
        val localVariableConfig = getProfileRelationshipsSegmentsRequestConfig(id = id, revision = revision)

        return request<Unit, GetProfileSegmentRelationshipsResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfileRelationshipsSegments
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return RequestConfig
     */
    fun getProfileRelationshipsSegmentsRequestConfig(id: kotlin.String, revision: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profiles/{id}/relationships/segments/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsSegment
     */
     enum class FieldsSegmentGetProfileSegments(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "definition") definition("definition"),
         @Json(name = "definition.condition_groups") definitionPeriodCondition_groups("definition.condition_groups"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "is_active") is_active("is_active"),
         @Json(name = "is_processing") is_processing("is_processing"),
         @Json(name = "is_starred") is_starred("is_starred");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Profile Segments
     * Get segment memberships for a profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;3/s&#x60;&lt;br&gt;Steady: &#x60;60/m&#x60;  **Scopes:** &#x60;profiles:read&#x60; &#x60;segments:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsSegment For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return GetSegmentResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfileSegments(id: kotlin.String, revision: kotlin.String = "2024-07-15", fieldsSegment: kotlin.collections.List<FieldsSegmentGetProfileSegments>? = null) : GetSegmentResponseCollection {
        val localVarResponse = getProfileSegmentsWithHttpInfo(id = id, revision = revision, fieldsSegment = fieldsSegment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSegmentResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Profile Segments
     * Get segment memberships for a profile with the given profile ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;3/s&#x60;&lt;br&gt;Steady: &#x60;60/m&#x60;  **Scopes:** &#x60;profiles:read&#x60; &#x60;segments:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsSegment For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return ApiResponse<GetSegmentResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfileSegmentsWithHttpInfo(id: kotlin.String, revision: kotlin.String, fieldsSegment: kotlin.collections.List<FieldsSegmentGetProfileSegments>?) : ApiResponse<GetSegmentResponseCollection?> {
        val localVariableConfig = getProfileSegmentsRequestConfig(id = id, revision = revision, fieldsSegment = fieldsSegment)

        return request<Unit, GetSegmentResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfileSegments
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsSegment For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return RequestConfig
     */
    fun getProfileSegmentsRequestConfig(id: kotlin.String, revision: kotlin.String, fieldsSegment: kotlin.collections.List<FieldsSegmentGetProfileSegments>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsSegment != null) {
                    put("fields[segment]", toMultiValue(fieldsSegment.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profiles/{id}/segments/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter additionalFieldsProfile
     */
     enum class AdditionalFieldsProfileGetProfiles(val value: kotlin.String) {
         @Json(name = "subscriptions") subscriptions("subscriptions"),
         @Json(name = "predictive_analytics") predictive_analytics("predictive_analytics");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsProfile
     */
     enum class FieldsProfileGetProfiles(val value: kotlin.String) {
         @Json(name = "email") email("email"),
         @Json(name = "phone_number") phone_number("phone_number"),
         @Json(name = "external_id") external_id("external_id"),
         @Json(name = "first_name") first_name("first_name"),
         @Json(name = "last_name") last_name("last_name"),
         @Json(name = "organization") organization("organization"),
         @Json(name = "locale") locale("locale"),
         @Json(name = "title") title("title"),
         @Json(name = "image") image("image"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "last_event_date") last_event_date("last_event_date"),
         @Json(name = "location") location("location"),
         @Json(name = "location.address1") locationPeriodAddress1("location.address1"),
         @Json(name = "location.address2") locationPeriodAddress2("location.address2"),
         @Json(name = "location.city") locationPeriodCity("location.city"),
         @Json(name = "location.country") locationPeriodCountry("location.country"),
         @Json(name = "location.latitude") locationPeriodLatitude("location.latitude"),
         @Json(name = "location.longitude") locationPeriodLongitude("location.longitude"),
         @Json(name = "location.region") locationPeriodRegion("location.region"),
         @Json(name = "location.zip") locationPeriodZip("location.zip"),
         @Json(name = "location.timezone") locationPeriodTimezone("location.timezone"),
         @Json(name = "location.ip") locationPeriodIp("location.ip"),
         @Json(name = "properties") properties("properties"),
         @Json(name = "subscriptions") subscriptions("subscriptions"),
         @Json(name = "subscriptions.email") subscriptionsPeriodEmail("subscriptions.email"),
         @Json(name = "subscriptions.email.marketing") subscriptionsPeriodEmailPeriodMarketing("subscriptions.email.marketing"),
         @Json(name = "subscriptions.email.marketing.can_receive_email_marketing") subscriptionsPeriodEmailPeriodMarketingPeriodCan_receive_email_marketing("subscriptions.email.marketing.can_receive_email_marketing"),
         @Json(name = "subscriptions.email.marketing.consent") subscriptionsPeriodEmailPeriodMarketingPeriodConsent("subscriptions.email.marketing.consent"),
         @Json(name = "subscriptions.email.marketing.consent_timestamp") subscriptionsPeriodEmailPeriodMarketingPeriodConsent_timestamp("subscriptions.email.marketing.consent_timestamp"),
         @Json(name = "subscriptions.email.marketing.last_updated") subscriptionsPeriodEmailPeriodMarketingPeriodLast_updated("subscriptions.email.marketing.last_updated"),
         @Json(name = "subscriptions.email.marketing.method") subscriptionsPeriodEmailPeriodMarketingPeriodMethod("subscriptions.email.marketing.method"),
         @Json(name = "subscriptions.email.marketing.method_detail") subscriptionsPeriodEmailPeriodMarketingPeriodMethod_detail("subscriptions.email.marketing.method_detail"),
         @Json(name = "subscriptions.email.marketing.custom_method_detail") subscriptionsPeriodEmailPeriodMarketingPeriodCustom_method_detail("subscriptions.email.marketing.custom_method_detail"),
         @Json(name = "subscriptions.email.marketing.double_optin") subscriptionsPeriodEmailPeriodMarketingPeriodDouble_optin("subscriptions.email.marketing.double_optin"),
         @Json(name = "subscriptions.email.marketing.suppression") subscriptionsPeriodEmailPeriodMarketingPeriodSuppression("subscriptions.email.marketing.suppression"),
         @Json(name = "subscriptions.email.marketing.list_suppressions") subscriptionsPeriodEmailPeriodMarketingPeriodList_suppressions("subscriptions.email.marketing.list_suppressions"),
         @Json(name = "subscriptions.sms") subscriptionsPeriodSms("subscriptions.sms"),
         @Json(name = "subscriptions.sms.marketing") subscriptionsPeriodSmsPeriodMarketing("subscriptions.sms.marketing"),
         @Json(name = "subscriptions.sms.marketing.can_receive_sms_marketing") subscriptionsPeriodSmsPeriodMarketingPeriodCan_receive_sms_marketing("subscriptions.sms.marketing.can_receive_sms_marketing"),
         @Json(name = "subscriptions.sms.marketing.consent") subscriptionsPeriodSmsPeriodMarketingPeriodConsent("subscriptions.sms.marketing.consent"),
         @Json(name = "subscriptions.sms.marketing.consent_timestamp") subscriptionsPeriodSmsPeriodMarketingPeriodConsent_timestamp("subscriptions.sms.marketing.consent_timestamp"),
         @Json(name = "subscriptions.sms.marketing.method") subscriptionsPeriodSmsPeriodMarketingPeriodMethod("subscriptions.sms.marketing.method"),
         @Json(name = "subscriptions.sms.marketing.method_detail") subscriptionsPeriodSmsPeriodMarketingPeriodMethod_detail("subscriptions.sms.marketing.method_detail"),
         @Json(name = "subscriptions.sms.marketing.last_updated") subscriptionsPeriodSmsPeriodMarketingPeriodLast_updated("subscriptions.sms.marketing.last_updated"),
         @Json(name = "subscriptions.mobile_push") subscriptionsPeriodMobile_push("subscriptions.mobile_push"),
         @Json(name = "subscriptions.mobile_push.marketing") subscriptionsPeriodMobile_pushPeriodMarketing("subscriptions.mobile_push.marketing"),
         @Json(name = "subscriptions.mobile_push.marketing.can_receive_push_marketing") subscriptionsPeriodMobile_pushPeriodMarketingPeriodCan_receive_push_marketing("subscriptions.mobile_push.marketing.can_receive_push_marketing"),
         @Json(name = "subscriptions.mobile_push.marketing.consent") subscriptionsPeriodMobile_pushPeriodMarketingPeriodConsent("subscriptions.mobile_push.marketing.consent"),
         @Json(name = "subscriptions.mobile_push.marketing.consent_timestamp") subscriptionsPeriodMobile_pushPeriodMarketingPeriodConsent_timestamp("subscriptions.mobile_push.marketing.consent_timestamp"),
         @Json(name = "predictive_analytics") predictive_analytics("predictive_analytics"),
         @Json(name = "predictive_analytics.historic_clv") predictive_analyticsPeriodHistoric_clv("predictive_analytics.historic_clv"),
         @Json(name = "predictive_analytics.predicted_clv") predictive_analyticsPeriodPredicted_clv("predictive_analytics.predicted_clv"),
         @Json(name = "predictive_analytics.total_clv") predictive_analyticsPeriodTotal_clv("predictive_analytics.total_clv"),
         @Json(name = "predictive_analytics.historic_number_of_orders") predictive_analyticsPeriodHistoric_number_of_orders("predictive_analytics.historic_number_of_orders"),
         @Json(name = "predictive_analytics.predicted_number_of_orders") predictive_analyticsPeriodPredicted_number_of_orders("predictive_analytics.predicted_number_of_orders"),
         @Json(name = "predictive_analytics.average_days_between_orders") predictive_analyticsPeriodAverage_days_between_orders("predictive_analytics.average_days_between_orders"),
         @Json(name = "predictive_analytics.average_order_value") predictive_analyticsPeriodAverage_order_value("predictive_analytics.average_order_value"),
         @Json(name = "predictive_analytics.churn_probability") predictive_analyticsPeriodChurn_probability("predictive_analytics.churn_probability"),
         @Json(name = "predictive_analytics.expected_date_of_next_order") predictive_analyticsPeriodExpected_date_of_next_order("predictive_analytics.expected_date_of_next_order");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetProfiles(val value: kotlin.String) {
         @Json(name = "created") created("created"),
         @Json(name = "-created") MinusCreated("-created"),
         @Json(name = "email") email("email"),
         @Json(name = "-email") MinusEmail("-email"),
         @Json(name = "id") id("id"),
         @Json(name = "-id") MinusId("-id"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "-updated") MinusUpdated("-updated"),
         @Json(name = "subscriptions.email.marketing.list_suppressions.timestamp") subscriptionsPeriodEmailPeriodMarketingPeriodList_suppressionsPeriodTimestamp("subscriptions.email.marketing.list_suppressions.timestamp"),
         @Json(name = "-subscriptions.email.marketing.list_suppressions.timestamp") MinusSubscriptionsPeriodEmailPeriodMarketingPeriodList_suppressionsPeriodTimestamp("-subscriptions.email.marketing.list_suppressions.timestamp"),
         @Json(name = "subscriptions.email.marketing.suppression.timestamp") subscriptionsPeriodEmailPeriodMarketingPeriodSuppressionPeriodTimestamp("subscriptions.email.marketing.suppression.timestamp"),
         @Json(name = "-subscriptions.email.marketing.suppression.timestamp") MinusSubscriptionsPeriodEmailPeriodMarketingPeriodSuppressionPeriodTimestamp("-subscriptions.email.marketing.suppression.timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Profiles
     * Get all profiles in an account.  Profiles can be sorted by the following fields in ascending and descending order: &#x60;id&#x60;, &#x60;created&#x60;, &#x60;updated&#x60;, &#x60;email&#x60;, &#x60;subscriptions.email.marketing.suppression.timestamp&#x60;, &#x60;subscriptions.email.marketing.list_suppressions.timestamp&#x60;&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;&lt;br&gt;&lt;br&gt;Rate limits when using the &#x60;additional-fields[profile]&#x3D;predictive_analytics&#x60; parameter in your API request:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;&lt;br&gt;&lt;br&gt;To learn more about how the &#x60;additional-fields&#x60; parameter impacts rate limits, check out our [Rate limits, status codes, and errors](https://developers.klaviyo.com/en/v2024-07-15/docs/rate_limits_and_error_handling) guide.  **Scopes:** &#x60;profiles:read&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;id&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;email&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;phone_number&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;external_id&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;_kx&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;created&#x60;: &#x60;greater-than&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;updated&#x60;: &#x60;greater-than&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.suppression.timestamp&#x60; : &#x60;greater-than&#x60;, &#x60;greater-or-equal&#x60;, &#x60;less-than&#x60;, &#x60;less-or-equal&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.suppression.reason&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.list_id&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.reason&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.timestamp&#x60; : &#x60;greater-than&#x60;, &#x60;greater-or-equal&#x60;, &#x60;less-than&#x60;, &#x60;less-or-equal&#x60; (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return GetProfileResponseCollectionCompoundDocument
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getProfiles(revision: kotlin.String = "2024-07-15", additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetProfiles>? = null, fieldsProfile: kotlin.collections.List<FieldsProfileGetProfiles>? = null, filter: kotlin.String? = null, pageCursor: kotlin.String? = null, pageSize: kotlin.Int? = 20, sort: SortGetProfiles? = null) : GetProfileResponseCollectionCompoundDocument {
        val localVarResponse = getProfilesWithHttpInfo(revision = revision, additionalFieldsProfile = additionalFieldsProfile, fieldsProfile = fieldsProfile, filter = filter, pageCursor = pageCursor, pageSize = pageSize, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileResponseCollectionCompoundDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Profiles
     * Get all profiles in an account.  Profiles can be sorted by the following fields in ascending and descending order: &#x60;id&#x60;, &#x60;created&#x60;, &#x60;updated&#x60;, &#x60;email&#x60;, &#x60;subscriptions.email.marketing.suppression.timestamp&#x60;, &#x60;subscriptions.email.marketing.list_suppressions.timestamp&#x60;&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;&lt;br&gt;&lt;br&gt;Rate limits when using the &#x60;additional-fields[profile]&#x3D;predictive_analytics&#x60; parameter in your API request:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;&lt;br&gt;&lt;br&gt;To learn more about how the &#x60;additional-fields&#x60; parameter impacts rate limits, check out our [Rate limits, status codes, and errors](https://developers.klaviyo.com/en/v2024-07-15/docs/rate_limits_and_error_handling) guide.  **Scopes:** &#x60;profiles:read&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;id&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;email&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;phone_number&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;external_id&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;_kx&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;created&#x60;: &#x60;greater-than&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;updated&#x60;: &#x60;greater-than&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.suppression.timestamp&#x60; : &#x60;greater-than&#x60;, &#x60;greater-or-equal&#x60;, &#x60;less-than&#x60;, &#x60;less-or-equal&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.suppression.reason&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.list_id&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.reason&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.timestamp&#x60; : &#x60;greater-than&#x60;, &#x60;greater-or-equal&#x60;, &#x60;less-than&#x60;, &#x60;less-or-equal&#x60; (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return ApiResponse<GetProfileResponseCollectionCompoundDocument?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getProfilesWithHttpInfo(revision: kotlin.String, additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetProfiles>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetProfiles>?, filter: kotlin.String?, pageCursor: kotlin.String?, pageSize: kotlin.Int?, sort: SortGetProfiles?) : ApiResponse<GetProfileResponseCollectionCompoundDocument?> {
        val localVariableConfig = getProfilesRequestConfig(revision = revision, additionalFieldsProfile = additionalFieldsProfile, fieldsProfile = fieldsProfile, filter = filter, pageCursor = pageCursor, pageSize = pageSize, sort = sort)

        return request<Unit, GetProfileResponseCollectionCompoundDocument>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getProfiles
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;id&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;email&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;phone_number&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;external_id&#x60;: &#x60;any&#x60;, &#x60;equals&#x60;&lt;br&gt;&#x60;_kx&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;created&#x60;: &#x60;greater-than&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;updated&#x60;: &#x60;greater-than&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.suppression.timestamp&#x60; : &#x60;greater-than&#x60;, &#x60;greater-or-equal&#x60;, &#x60;less-than&#x60;, &#x60;less-or-equal&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.suppression.reason&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.list_id&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.reason&#x60; : &#x60;equals&#x60;&lt;br&gt;&#x60;subscriptions.email.marketing.list_suppressions.timestamp&#x60; : &#x60;greater-than&#x60;, &#x60;greater-or-equal&#x60;, &#x60;less-than&#x60;, &#x60;less-or-equal&#x60; (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param pageSize Default: 20. Min: 1. Max: 100. (optional, default to 20)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return RequestConfig
     */
    fun getProfilesRequestConfig(revision: kotlin.String, additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetProfiles>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetProfiles>?, filter: kotlin.String?, pageCursor: kotlin.String?, pageSize: kotlin.Int?, sort: SortGetProfiles?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (additionalFieldsProfile != null) {
                    put("additional-fields[profile]", toMultiValue(additionalFieldsProfile.toList(), "csv"))
                }
                if (fieldsProfile != null) {
                    put("fields[profile]", toMultiValue(fieldsProfile.toList(), "csv"))
                }
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
                if (pageCursor != null) {
                    put("page[cursor]", listOf(pageCursor.toString()))
                }
                if (pageSize != null) {
                    put("page[size]", listOf(pageSize.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/profiles/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Merge Profiles
     * Merge a given related profile into a profile with the given profile ID.  The profile provided under &#x60;relationships&#x60; (the \&quot;source\&quot; profile) will be merged into the profile provided by the ID in the base data object (the \&quot;destination\&quot; profile). This endpoint queues an asynchronous task which will merge data from the source profile into the destination profile, deleting the source profile in the process. This endpoint accepts only one source profile.  To learn more about how profile data is preserved or overwritten during a merge, please [visit our Help Center](https://help.klaviyo.com/hc/en-us/articles/115005073847#merge-2-profiles3).&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;profiles:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileMergeQuery 
     * @return PostProfileMergeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mergeProfiles(revision: kotlin.String = "2024-07-15", profileMergeQuery: ProfileMergeQuery) : PostProfileMergeResponse {
        val localVarResponse = mergeProfilesWithHttpInfo(revision = revision, profileMergeQuery = profileMergeQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostProfileMergeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Merge Profiles
     * Merge a given related profile into a profile with the given profile ID.  The profile provided under &#x60;relationships&#x60; (the \&quot;source\&quot; profile) will be merged into the profile provided by the ID in the base data object (the \&quot;destination\&quot; profile). This endpoint queues an asynchronous task which will merge data from the source profile into the destination profile, deleting the source profile in the process. This endpoint accepts only one source profile.  To learn more about how profile data is preserved or overwritten during a merge, please [visit our Help Center](https://help.klaviyo.com/hc/en-us/articles/115005073847#merge-2-profiles3).&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;profiles:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileMergeQuery 
     * @return ApiResponse<PostProfileMergeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mergeProfilesWithHttpInfo(revision: kotlin.String, profileMergeQuery: ProfileMergeQuery) : ApiResponse<PostProfileMergeResponse?> {
        val localVariableConfig = mergeProfilesRequestConfig(revision = revision, profileMergeQuery = profileMergeQuery)

        return request<ProfileMergeQuery, PostProfileMergeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mergeProfiles
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileMergeQuery 
     * @return RequestConfig
     */
    fun mergeProfilesRequestConfig(revision: kotlin.String, profileMergeQuery: ProfileMergeQuery) : RequestConfig<ProfileMergeQuery> {
        val localVariableBody = profileMergeQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/profile-merge/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Spawn Bulk Profile Import Job
     * Create a bulk profile import job to create or update a batch of profiles.  Accepts up to 10,000 profiles per request. The maximum allowed payload size is 5MB.  To learn more, see our [Bulk Profile Import API guide](https://developers.klaviyo.com/en/docs/use_klaviyos_bulk_profile_import_api).&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:write&#x60; &#x60;profiles:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileImportJobCreateQuery 
     * @return PostProfileImportJobResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun spawnBulkProfileImportJob(revision: kotlin.String = "2024-07-15", profileImportJobCreateQuery: ProfileImportJobCreateQuery) : PostProfileImportJobResponse {
        val localVarResponse = spawnBulkProfileImportJobWithHttpInfo(revision = revision, profileImportJobCreateQuery = profileImportJobCreateQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostProfileImportJobResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Spawn Bulk Profile Import Job
     * Create a bulk profile import job to create or update a batch of profiles.  Accepts up to 10,000 profiles per request. The maximum allowed payload size is 5MB.  To learn more, see our [Bulk Profile Import API guide](https://developers.klaviyo.com/en/docs/use_klaviyos_bulk_profile_import_api).&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;lists:write&#x60; &#x60;profiles:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileImportJobCreateQuery 
     * @return ApiResponse<PostProfileImportJobResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun spawnBulkProfileImportJobWithHttpInfo(revision: kotlin.String, profileImportJobCreateQuery: ProfileImportJobCreateQuery) : ApiResponse<PostProfileImportJobResponse?> {
        val localVariableConfig = spawnBulkProfileImportJobRequestConfig(revision = revision, profileImportJobCreateQuery = profileImportJobCreateQuery)

        return request<ProfileImportJobCreateQuery, PostProfileImportJobResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation spawnBulkProfileImportJob
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profileImportJobCreateQuery 
     * @return RequestConfig
     */
    fun spawnBulkProfileImportJobRequestConfig(revision: kotlin.String, profileImportJobCreateQuery: ProfileImportJobCreateQuery) : RequestConfig<ProfileImportJobCreateQuery> {
        val localVariableBody = profileImportJobCreateQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/profile-bulk-import-jobs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Subscribe Profiles
     * Subscribe one or more profiles to email marketing, SMS marketing, or both. If the provided list has double opt-in enabled, profiles will receive a message requiring their confirmation before subscribing. Otherwise, profiles will be immediately subscribed without receiving a confirmation message. Learn more about [consent in this guide](https://developers.klaviyo.com/en/docs/collect_email_and_sms_consent_via_api).  If a list is not provided, the opt-in process used will be determined by the [account-level default opt-in setting](https://www.klaviyo.com/settings/account/api-keys).  To add someone to a list without changing their subscription status, use [Add Profile to List](https://developers.klaviyo.com/en/reference/create_list_relationships).  This API will remove any &#x60;UNSUBSCRIBE&#x60;, &#x60;SPAM_REPORT&#x60; or &#x60;USER_SUPPRESSED&#x60; suppressions from the provided profiles. Learn more about [suppressed profiles](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1).  Maximum number of profiles can be submitted for subscription: 1000  This endpoint now supports a &#x60;historical_import&#x60; flag. If this flag is set &#x60;true&#x60;, profiles being subscribed will bypass double opt-in emails and be subscribed immediately. They will also bypass any associated \&quot;Added to list\&quot; flows. This is useful for importing historical data where you have already collected consent. If &#x60;historical_import&#x60; is set to true, the &#x60;consented_at&#x60; field is required and must be in the past.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;lists:write&#x60; &#x60;profiles:write&#x60; &#x60;subscriptions:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param subscriptionCreateJobCreateQuery Subscribes one or more profiles to marketing. Currently, supports email and SMS only. All profiles will be added to the provided list. Either email or phone number is required. Both may be specified to subscribe to both channels. If a profile cannot be found matching the given identifier(s), a new profile will be created and then subscribed.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun subscribeProfiles(revision: kotlin.String = "2024-07-15", subscriptionCreateJobCreateQuery: SubscriptionCreateJobCreateQuery) : Unit {
        val localVarResponse = subscribeProfilesWithHttpInfo(revision = revision, subscriptionCreateJobCreateQuery = subscriptionCreateJobCreateQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Subscribe Profiles
     * Subscribe one or more profiles to email marketing, SMS marketing, or both. If the provided list has double opt-in enabled, profiles will receive a message requiring their confirmation before subscribing. Otherwise, profiles will be immediately subscribed without receiving a confirmation message. Learn more about [consent in this guide](https://developers.klaviyo.com/en/docs/collect_email_and_sms_consent_via_api).  If a list is not provided, the opt-in process used will be determined by the [account-level default opt-in setting](https://www.klaviyo.com/settings/account/api-keys).  To add someone to a list without changing their subscription status, use [Add Profile to List](https://developers.klaviyo.com/en/reference/create_list_relationships).  This API will remove any &#x60;UNSUBSCRIBE&#x60;, &#x60;SPAM_REPORT&#x60; or &#x60;USER_SUPPRESSED&#x60; suppressions from the provided profiles. Learn more about [suppressed profiles](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1).  Maximum number of profiles can be submitted for subscription: 1000  This endpoint now supports a &#x60;historical_import&#x60; flag. If this flag is set &#x60;true&#x60;, profiles being subscribed will bypass double opt-in emails and be subscribed immediately. They will also bypass any associated \&quot;Added to list\&quot; flows. This is useful for importing historical data where you have already collected consent. If &#x60;historical_import&#x60; is set to true, the &#x60;consented_at&#x60; field is required and must be in the past.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;lists:write&#x60; &#x60;profiles:write&#x60; &#x60;subscriptions:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param subscriptionCreateJobCreateQuery Subscribes one or more profiles to marketing. Currently, supports email and SMS only. All profiles will be added to the provided list. Either email or phone number is required. Both may be specified to subscribe to both channels. If a profile cannot be found matching the given identifier(s), a new profile will be created and then subscribed.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun subscribeProfilesWithHttpInfo(revision: kotlin.String, subscriptionCreateJobCreateQuery: SubscriptionCreateJobCreateQuery) : ApiResponse<Unit?> {
        val localVariableConfig = subscribeProfilesRequestConfig(revision = revision, subscriptionCreateJobCreateQuery = subscriptionCreateJobCreateQuery)

        return request<SubscriptionCreateJobCreateQuery, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation subscribeProfiles
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param subscriptionCreateJobCreateQuery Subscribes one or more profiles to marketing. Currently, supports email and SMS only. All profiles will be added to the provided list. Either email or phone number is required. Both may be specified to subscribe to both channels. If a profile cannot be found matching the given identifier(s), a new profile will be created and then subscribed.
     * @return RequestConfig
     */
    fun subscribeProfilesRequestConfig(revision: kotlin.String, subscriptionCreateJobCreateQuery: SubscriptionCreateJobCreateQuery) : RequestConfig<SubscriptionCreateJobCreateQuery> {
        val localVariableBody = subscriptionCreateJobCreateQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/profile-subscription-bulk-create-jobs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Suppress Profiles
     * Manually suppress profiles using their email address, or by specifying a segment or list ID to suppress all current members.  Suppressed profiles cannot receive email marketing, independent of their consent status. To learn more, see our [email suppressions guide](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1) and our [collecting consent guide](https://developers.klaviyo.com/en/docs/collect_email_and_sms_consent_via_api).  Email addresses per request limit: 100&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60; &#x60;subscriptions:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param suppressionCreateJobCreateQuery Suppresses one or more profiles from receiving marketing. Currently, supports email only. If a profile is not found with the given email, one will be created and immediately suppressed.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun suppressProfiles(revision: kotlin.String = "2024-07-15", suppressionCreateJobCreateQuery: SuppressionCreateJobCreateQuery) : Unit {
        val localVarResponse = suppressProfilesWithHttpInfo(revision = revision, suppressionCreateJobCreateQuery = suppressionCreateJobCreateQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Suppress Profiles
     * Manually suppress profiles using their email address, or by specifying a segment or list ID to suppress all current members.  Suppressed profiles cannot receive email marketing, independent of their consent status. To learn more, see our [email suppressions guide](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1) and our [collecting consent guide](https://developers.klaviyo.com/en/docs/collect_email_and_sms_consent_via_api).  Email addresses per request limit: 100&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60; &#x60;subscriptions:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param suppressionCreateJobCreateQuery Suppresses one or more profiles from receiving marketing. Currently, supports email only. If a profile is not found with the given email, one will be created and immediately suppressed.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun suppressProfilesWithHttpInfo(revision: kotlin.String, suppressionCreateJobCreateQuery: SuppressionCreateJobCreateQuery) : ApiResponse<Unit?> {
        val localVariableConfig = suppressProfilesRequestConfig(revision = revision, suppressionCreateJobCreateQuery = suppressionCreateJobCreateQuery)

        return request<SuppressionCreateJobCreateQuery, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation suppressProfiles
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param suppressionCreateJobCreateQuery Suppresses one or more profiles from receiving marketing. Currently, supports email only. If a profile is not found with the given email, one will be created and immediately suppressed.
     * @return RequestConfig
     */
    fun suppressProfilesRequestConfig(revision: kotlin.String, suppressionCreateJobCreateQuery: SuppressionCreateJobCreateQuery) : RequestConfig<SuppressionCreateJobCreateQuery> {
        val localVariableBody = suppressionCreateJobCreateQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/profile-suppression-bulk-create-jobs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Unsubscribe Profiles
     * Unsubscribe one or more profiles to email marketing, SMS marketing, or both. Learn more about [consent in this guide](https://developers.klaviyo.com/en/docs/collect_email_and_sms_consent_via_api).  To remove someone from a list without changing their subscription status, use [Remove Profile from List](https://developers.klaviyo.com/en/reference/delete_list_relationships).  Maximum number of profile can be submitted for unsubscription: 100&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;lists:write&#x60; &#x60;profiles:write&#x60; &#x60;subscriptions:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param subscriptionDeleteJobCreateQuery Unsubscribes one or more profiles from marketing. Currently, supports email and SMS only. All profiles will be removed from the provided list. Either email or phone number is required. If a profile cannot be found matching the given identifier(s), a new profile will be created and then unsubscribed.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun unsubscribeProfiles(revision: kotlin.String = "2024-07-15", subscriptionDeleteJobCreateQuery: SubscriptionDeleteJobCreateQuery) : Unit {
        val localVarResponse = unsubscribeProfilesWithHttpInfo(revision = revision, subscriptionDeleteJobCreateQuery = subscriptionDeleteJobCreateQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unsubscribe Profiles
     * Unsubscribe one or more profiles to email marketing, SMS marketing, or both. Learn more about [consent in this guide](https://developers.klaviyo.com/en/docs/collect_email_and_sms_consent_via_api).  To remove someone from a list without changing their subscription status, use [Remove Profile from List](https://developers.klaviyo.com/en/reference/delete_list_relationships).  Maximum number of profile can be submitted for unsubscription: 100&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;lists:write&#x60; &#x60;profiles:write&#x60; &#x60;subscriptions:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param subscriptionDeleteJobCreateQuery Unsubscribes one or more profiles from marketing. Currently, supports email and SMS only. All profiles will be removed from the provided list. Either email or phone number is required. If a profile cannot be found matching the given identifier(s), a new profile will be created and then unsubscribed.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun unsubscribeProfilesWithHttpInfo(revision: kotlin.String, subscriptionDeleteJobCreateQuery: SubscriptionDeleteJobCreateQuery) : ApiResponse<Unit?> {
        val localVariableConfig = unsubscribeProfilesRequestConfig(revision = revision, subscriptionDeleteJobCreateQuery = subscriptionDeleteJobCreateQuery)

        return request<SubscriptionDeleteJobCreateQuery, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation unsubscribeProfiles
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param subscriptionDeleteJobCreateQuery Unsubscribes one or more profiles from marketing. Currently, supports email and SMS only. All profiles will be removed from the provided list. Either email or phone number is required. If a profile cannot be found matching the given identifier(s), a new profile will be created and then unsubscribed.
     * @return RequestConfig
     */
    fun unsubscribeProfilesRequestConfig(revision: kotlin.String, subscriptionDeleteJobCreateQuery: SubscriptionDeleteJobCreateQuery) : RequestConfig<SubscriptionDeleteJobCreateQuery> {
        val localVariableBody = subscriptionDeleteJobCreateQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/profile-subscription-bulk-delete-jobs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Unsuppress Profiles
     * Manually unsuppress profiles using their email address, or by specifying a segment or list ID to unsuppress all current members.  This only removes suppressions with reason &#x60;USER_SUPPRESSED&#x60;, leaving unsubscribed profiles and profiles suppressed with reason &#x60;INVALID_EMAIL&#x60; or &#x60;HARD_BOUNCE&#x60; unchanged. To learn more, see our [email suppressions guide](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1) and our [collecting consent guide](https://developers.klaviyo.com/en/docs/collect_email_and_sms_consent_via_api).  Email addresses per request limit: 100&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;subscriptions:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param suppressionDeleteJobCreateQuery Unsuppresses one or more profiles from receiving marketing. Currently, supports email only. If a profile is not found with the given email, no action will be taken.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun unsuppressProfiles(revision: kotlin.String = "2024-07-15", suppressionDeleteJobCreateQuery: SuppressionDeleteJobCreateQuery) : Unit {
        val localVarResponse = unsuppressProfilesWithHttpInfo(revision = revision, suppressionDeleteJobCreateQuery = suppressionDeleteJobCreateQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unsuppress Profiles
     * Manually unsuppress profiles using their email address, or by specifying a segment or list ID to unsuppress all current members.  This only removes suppressions with reason &#x60;USER_SUPPRESSED&#x60;, leaving unsubscribed profiles and profiles suppressed with reason &#x60;INVALID_EMAIL&#x60; or &#x60;HARD_BOUNCE&#x60; unchanged. To learn more, see our [email suppressions guide](https://help.klaviyo.com/hc/en-us/articles/115005246108-Understanding-suppressed-email-profiles#what-is-a-suppressed-profile-1) and our [collecting consent guide](https://developers.klaviyo.com/en/docs/collect_email_and_sms_consent_via_api).  Email addresses per request limit: 100&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;subscriptions:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param suppressionDeleteJobCreateQuery Unsuppresses one or more profiles from receiving marketing. Currently, supports email only. If a profile is not found with the given email, no action will be taken.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun unsuppressProfilesWithHttpInfo(revision: kotlin.String, suppressionDeleteJobCreateQuery: SuppressionDeleteJobCreateQuery) : ApiResponse<Unit?> {
        val localVariableConfig = unsuppressProfilesRequestConfig(revision = revision, suppressionDeleteJobCreateQuery = suppressionDeleteJobCreateQuery)

        return request<SuppressionDeleteJobCreateQuery, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation unsuppressProfiles
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param suppressionDeleteJobCreateQuery Unsuppresses one or more profiles from receiving marketing. Currently, supports email only. If a profile is not found with the given email, no action will be taken.
     * @return RequestConfig
     */
    fun unsuppressProfilesRequestConfig(revision: kotlin.String, suppressionDeleteJobCreateQuery: SuppressionDeleteJobCreateQuery) : RequestConfig<SuppressionDeleteJobCreateQuery> {
        val localVariableBody = suppressionDeleteJobCreateQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/profile-suppression-bulk-delete-jobs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update Profile
     * Update the profile with the given profile ID.  Note that setting a field to &#x60;null&#x60; will clear out the field, whereas not including a field in your request will leave it unchanged.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60;
     * @param id Primary key that uniquely identifies this profile. Generated by Klaviyo.
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profilePartialUpdateQuery 
     * @return PatchProfileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateProfile(id: kotlin.String, revision: kotlin.String = "2024-07-15", profilePartialUpdateQuery: ProfilePartialUpdateQuery) : PatchProfileResponse {
        val localVarResponse = updateProfileWithHttpInfo(id = id, revision = revision, profilePartialUpdateQuery = profilePartialUpdateQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PatchProfileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update Profile
     * Update the profile with the given profile ID.  Note that setting a field to &#x60;null&#x60; will clear out the field, whereas not including a field in your request will leave it unchanged.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;75/s&#x60;&lt;br&gt;Steady: &#x60;700/m&#x60;  **Scopes:** &#x60;profiles:write&#x60;
     * @param id Primary key that uniquely identifies this profile. Generated by Klaviyo.
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profilePartialUpdateQuery 
     * @return ApiResponse<PatchProfileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateProfileWithHttpInfo(id: kotlin.String, revision: kotlin.String, profilePartialUpdateQuery: ProfilePartialUpdateQuery) : ApiResponse<PatchProfileResponse?> {
        val localVariableConfig = updateProfileRequestConfig(id = id, revision = revision, profilePartialUpdateQuery = profilePartialUpdateQuery)

        return request<ProfilePartialUpdateQuery, PatchProfileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateProfile
     *
     * @param id Primary key that uniquely identifies this profile. Generated by Klaviyo.
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param profilePartialUpdateQuery 
     * @return RequestConfig
     */
    fun updateProfileRequestConfig(id: kotlin.String, revision: kotlin.String, profilePartialUpdateQuery: ProfilePartialUpdateQuery) : RequestConfig<ProfilePartialUpdateQuery> {
        val localVariableBody = profilePartialUpdateQuery
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/profiles/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
