/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.EventCreateQueryV2
import org.openapitools.client.models.EventsBulkCreateJob
import org.openapitools.client.models.GetAccounts4XXResponse
import org.openapitools.client.models.GetEventMetricsRelationshipListResponse
import org.openapitools.client.models.GetEventProfilesRelationshipListResponse
import org.openapitools.client.models.GetEventResponseCollectionCompoundDocument
import org.openapitools.client.models.GetEventResponseCompoundDocument
import org.openapitools.client.models.GetMetricResponseCollection
import org.openapitools.client.models.GetProfileResponseCollection

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class EventsApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://a.klaviyo.com")
        }
    }

    /**
     * Bulk Create Events
     * Create a batch of events for one or more profiles.  Note that this endpoint allows you to create new profiles or update existing profile properties.  At a minimum, profile and metric objects should include at least one profile identifier (e.g., &#x60;id&#x60;, &#x60;email&#x60;, or &#x60;phone_number&#x60;) and the metric &#x60;name&#x60;, respectively.  Accepts up to 1,000 events per request. The maximum allowed payload size is 5MB.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;events:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param eventsBulkCreateJob 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun bulkCreateEvents(revision: kotlin.String = "2024-07-15", eventsBulkCreateJob: EventsBulkCreateJob) : Unit {
        val localVarResponse = bulkCreateEventsWithHttpInfo(revision = revision, eventsBulkCreateJob = eventsBulkCreateJob)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Bulk Create Events
     * Create a batch of events for one or more profiles.  Note that this endpoint allows you to create new profiles or update existing profile properties.  At a minimum, profile and metric objects should include at least one profile identifier (e.g., &#x60;id&#x60;, &#x60;email&#x60;, or &#x60;phone_number&#x60;) and the metric &#x60;name&#x60;, respectively.  Accepts up to 1,000 events per request. The maximum allowed payload size is 5MB.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;events:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param eventsBulkCreateJob 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun bulkCreateEventsWithHttpInfo(revision: kotlin.String, eventsBulkCreateJob: EventsBulkCreateJob) : ApiResponse<Unit?> {
        val localVariableConfig = bulkCreateEventsRequestConfig(revision = revision, eventsBulkCreateJob = eventsBulkCreateJob)

        return request<EventsBulkCreateJob, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation bulkCreateEvents
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param eventsBulkCreateJob 
     * @return RequestConfig
     */
    fun bulkCreateEventsRequestConfig(revision: kotlin.String, eventsBulkCreateJob: EventsBulkCreateJob) : RequestConfig<EventsBulkCreateJob> {
        val localVariableBody = eventsBulkCreateJob
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/event-bulk-create-jobs/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create Event
     * Create a new event to track a profile&#39;s activity.  Note that this endpoint allows you to create a new profile or update an existing profile&#39;s properties.  At a minimum, profile and metric objects should include at least one profile identifier (e.g., &#x60;id&#x60;, &#x60;email&#x60;, or &#x60;phone_number&#x60;) and the metric &#x60;name&#x60;, respectively.  Successful response indicates that the event was validated and submitted for processing, but does not guarantee that processing is complete.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param eventCreateQueryV2 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEvent(revision: kotlin.String = "2024-07-15", eventCreateQueryV2: EventCreateQueryV2) : Unit {
        val localVarResponse = createEventWithHttpInfo(revision = revision, eventCreateQueryV2 = eventCreateQueryV2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create Event
     * Create a new event to track a profile&#39;s activity.  Note that this endpoint allows you to create a new profile or update an existing profile&#39;s properties.  At a minimum, profile and metric objects should include at least one profile identifier (e.g., &#x60;id&#x60;, &#x60;email&#x60;, or &#x60;phone_number&#x60;) and the metric &#x60;name&#x60;, respectively.  Successful response indicates that the event was validated and submitted for processing, but does not guarantee that processing is complete.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:write&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param eventCreateQueryV2 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun createEventWithHttpInfo(revision: kotlin.String, eventCreateQueryV2: EventCreateQueryV2) : ApiResponse<Unit?> {
        val localVariableConfig = createEventRequestConfig(revision = revision, eventCreateQueryV2 = eventCreateQueryV2)

        return request<EventCreateQueryV2, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEvent
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param eventCreateQueryV2 
     * @return RequestConfig
     */
    fun createEventRequestConfig(revision: kotlin.String, eventCreateQueryV2: EventCreateQueryV2) : RequestConfig<EventCreateQueryV2> {
        val localVariableBody = eventCreateQueryV2
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/events/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsEvent
     */
     enum class FieldsEventGetEvent(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp"),
         @Json(name = "event_properties") event_properties("event_properties"),
         @Json(name = "datetime") datetime("datetime"),
         @Json(name = "uuid") uuid("uuid");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsMetric
     */
     enum class FieldsMetricGetEvent(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "integration") integration("integration");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsProfile
     */
     enum class FieldsProfileGetEvent(val value: kotlin.String) {
         @Json(name = "email") email("email"),
         @Json(name = "phone_number") phone_number("phone_number"),
         @Json(name = "external_id") external_id("external_id"),
         @Json(name = "first_name") first_name("first_name"),
         @Json(name = "last_name") last_name("last_name"),
         @Json(name = "organization") organization("organization"),
         @Json(name = "locale") locale("locale"),
         @Json(name = "title") title("title"),
         @Json(name = "image") image("image"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "last_event_date") last_event_date("last_event_date"),
         @Json(name = "location") location("location"),
         @Json(name = "location.address1") locationPeriodAddress1("location.address1"),
         @Json(name = "location.address2") locationPeriodAddress2("location.address2"),
         @Json(name = "location.city") locationPeriodCity("location.city"),
         @Json(name = "location.country") locationPeriodCountry("location.country"),
         @Json(name = "location.latitude") locationPeriodLatitude("location.latitude"),
         @Json(name = "location.longitude") locationPeriodLongitude("location.longitude"),
         @Json(name = "location.region") locationPeriodRegion("location.region"),
         @Json(name = "location.zip") locationPeriodZip("location.zip"),
         @Json(name = "location.timezone") locationPeriodTimezone("location.timezone"),
         @Json(name = "location.ip") locationPeriodIp("location.ip"),
         @Json(name = "properties") properties("properties");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter include
     */
     enum class IncludeGetEvent(val value: kotlin.String) {
         @Json(name = "attributions") attributions("attributions"),
         @Json(name = "metric") metric("metric"),
         @Json(name = "profile") profile("profile");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Event
     * Get an event with the given event ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;events:read&#x60;
     * @param id ID of the event
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsEvent For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return GetEventResponseCompoundDocument
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEvent(id: kotlin.String, revision: kotlin.String = "2024-07-15", fieldsEvent: kotlin.collections.List<FieldsEventGetEvent>? = null, fieldsMetric: kotlin.collections.List<FieldsMetricGetEvent>? = null, fieldsProfile: kotlin.collections.List<FieldsProfileGetEvent>? = null, include: kotlin.collections.List<IncludeGetEvent>? = null) : GetEventResponseCompoundDocument {
        val localVarResponse = getEventWithHttpInfo(id = id, revision = revision, fieldsEvent = fieldsEvent, fieldsMetric = fieldsMetric, fieldsProfile = fieldsProfile, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEventResponseCompoundDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Event
     * Get an event with the given event ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;10/s&#x60;&lt;br&gt;Steady: &#x60;150/m&#x60;  **Scopes:** &#x60;events:read&#x60;
     * @param id ID of the event
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsEvent For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return ApiResponse<GetEventResponseCompoundDocument?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventWithHttpInfo(id: kotlin.String, revision: kotlin.String, fieldsEvent: kotlin.collections.List<FieldsEventGetEvent>?, fieldsMetric: kotlin.collections.List<FieldsMetricGetEvent>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetEvent>?, include: kotlin.collections.List<IncludeGetEvent>?) : ApiResponse<GetEventResponseCompoundDocument?> {
        val localVariableConfig = getEventRequestConfig(id = id, revision = revision, fieldsEvent = fieldsEvent, fieldsMetric = fieldsMetric, fieldsProfile = fieldsProfile, include = include)

        return request<Unit, GetEventResponseCompoundDocument>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEvent
     *
     * @param id ID of the event
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsEvent For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @return RequestConfig
     */
    fun getEventRequestConfig(id: kotlin.String, revision: kotlin.String, fieldsEvent: kotlin.collections.List<FieldsEventGetEvent>?, fieldsMetric: kotlin.collections.List<FieldsMetricGetEvent>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetEvent>?, include: kotlin.collections.List<IncludeGetEvent>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsEvent != null) {
                    put("fields[event]", toMultiValue(fieldsEvent.toList(), "csv"))
                }
                if (fieldsMetric != null) {
                    put("fields[metric]", toMultiValue(fieldsMetric.toList(), "csv"))
                }
                if (fieldsProfile != null) {
                    put("fields[profile]", toMultiValue(fieldsProfile.toList(), "csv"))
                }
                if (include != null) {
                    put("include", toMultiValue(include.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/events/{id}/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsMetric
     */
     enum class FieldsMetricGetEventMetric(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "integration") integration("integration");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Event Metric
     * Get the metric for an event with the given event ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60; &#x60;metrics:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return GetMetricResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEventMetric(id: kotlin.String, revision: kotlin.String = "2024-07-15", fieldsMetric: kotlin.collections.List<FieldsMetricGetEventMetric>? = null) : GetMetricResponseCollection {
        val localVarResponse = getEventMetricWithHttpInfo(id = id, revision = revision, fieldsMetric = fieldsMetric)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMetricResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Event Metric
     * Get the metric for an event with the given event ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60; &#x60;metrics:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return ApiResponse<GetMetricResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventMetricWithHttpInfo(id: kotlin.String, revision: kotlin.String, fieldsMetric: kotlin.collections.List<FieldsMetricGetEventMetric>?) : ApiResponse<GetMetricResponseCollection?> {
        val localVariableConfig = getEventMetricRequestConfig(id = id, revision = revision, fieldsMetric = fieldsMetric)

        return request<Unit, GetMetricResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEventMetric
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return RequestConfig
     */
    fun getEventMetricRequestConfig(id: kotlin.String, revision: kotlin.String, fieldsMetric: kotlin.collections.List<FieldsMetricGetEventMetric>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsMetric != null) {
                    put("fields[metric]", toMultiValue(fieldsMetric.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/events/{id}/metric/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter additionalFieldsProfile
     */
     enum class AdditionalFieldsProfileGetEventProfile(val value: kotlin.String) {
         @Json(name = "subscriptions") subscriptions("subscriptions"),
         @Json(name = "predictive_analytics") predictive_analytics("predictive_analytics");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsProfile
     */
     enum class FieldsProfileGetEventProfile(val value: kotlin.String) {
         @Json(name = "email") email("email"),
         @Json(name = "phone_number") phone_number("phone_number"),
         @Json(name = "external_id") external_id("external_id"),
         @Json(name = "first_name") first_name("first_name"),
         @Json(name = "last_name") last_name("last_name"),
         @Json(name = "organization") organization("organization"),
         @Json(name = "locale") locale("locale"),
         @Json(name = "title") title("title"),
         @Json(name = "image") image("image"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "last_event_date") last_event_date("last_event_date"),
         @Json(name = "location") location("location"),
         @Json(name = "location.address1") locationPeriodAddress1("location.address1"),
         @Json(name = "location.address2") locationPeriodAddress2("location.address2"),
         @Json(name = "location.city") locationPeriodCity("location.city"),
         @Json(name = "location.country") locationPeriodCountry("location.country"),
         @Json(name = "location.latitude") locationPeriodLatitude("location.latitude"),
         @Json(name = "location.longitude") locationPeriodLongitude("location.longitude"),
         @Json(name = "location.region") locationPeriodRegion("location.region"),
         @Json(name = "location.zip") locationPeriodZip("location.zip"),
         @Json(name = "location.timezone") locationPeriodTimezone("location.timezone"),
         @Json(name = "location.ip") locationPeriodIp("location.ip"),
         @Json(name = "properties") properties("properties"),
         @Json(name = "subscriptions") subscriptions("subscriptions"),
         @Json(name = "subscriptions.email") subscriptionsPeriodEmail("subscriptions.email"),
         @Json(name = "subscriptions.email.marketing") subscriptionsPeriodEmailPeriodMarketing("subscriptions.email.marketing"),
         @Json(name = "subscriptions.email.marketing.can_receive_email_marketing") subscriptionsPeriodEmailPeriodMarketingPeriodCan_receive_email_marketing("subscriptions.email.marketing.can_receive_email_marketing"),
         @Json(name = "subscriptions.email.marketing.consent") subscriptionsPeriodEmailPeriodMarketingPeriodConsent("subscriptions.email.marketing.consent"),
         @Json(name = "subscriptions.email.marketing.consent_timestamp") subscriptionsPeriodEmailPeriodMarketingPeriodConsent_timestamp("subscriptions.email.marketing.consent_timestamp"),
         @Json(name = "subscriptions.email.marketing.last_updated") subscriptionsPeriodEmailPeriodMarketingPeriodLast_updated("subscriptions.email.marketing.last_updated"),
         @Json(name = "subscriptions.email.marketing.method") subscriptionsPeriodEmailPeriodMarketingPeriodMethod("subscriptions.email.marketing.method"),
         @Json(name = "subscriptions.email.marketing.method_detail") subscriptionsPeriodEmailPeriodMarketingPeriodMethod_detail("subscriptions.email.marketing.method_detail"),
         @Json(name = "subscriptions.email.marketing.custom_method_detail") subscriptionsPeriodEmailPeriodMarketingPeriodCustom_method_detail("subscriptions.email.marketing.custom_method_detail"),
         @Json(name = "subscriptions.email.marketing.double_optin") subscriptionsPeriodEmailPeriodMarketingPeriodDouble_optin("subscriptions.email.marketing.double_optin"),
         @Json(name = "subscriptions.email.marketing.suppression") subscriptionsPeriodEmailPeriodMarketingPeriodSuppression("subscriptions.email.marketing.suppression"),
         @Json(name = "subscriptions.email.marketing.list_suppressions") subscriptionsPeriodEmailPeriodMarketingPeriodList_suppressions("subscriptions.email.marketing.list_suppressions"),
         @Json(name = "subscriptions.sms") subscriptionsPeriodSms("subscriptions.sms"),
         @Json(name = "subscriptions.sms.marketing") subscriptionsPeriodSmsPeriodMarketing("subscriptions.sms.marketing"),
         @Json(name = "subscriptions.sms.marketing.can_receive_sms_marketing") subscriptionsPeriodSmsPeriodMarketingPeriodCan_receive_sms_marketing("subscriptions.sms.marketing.can_receive_sms_marketing"),
         @Json(name = "subscriptions.sms.marketing.consent") subscriptionsPeriodSmsPeriodMarketingPeriodConsent("subscriptions.sms.marketing.consent"),
         @Json(name = "subscriptions.sms.marketing.consent_timestamp") subscriptionsPeriodSmsPeriodMarketingPeriodConsent_timestamp("subscriptions.sms.marketing.consent_timestamp"),
         @Json(name = "subscriptions.sms.marketing.method") subscriptionsPeriodSmsPeriodMarketingPeriodMethod("subscriptions.sms.marketing.method"),
         @Json(name = "subscriptions.sms.marketing.method_detail") subscriptionsPeriodSmsPeriodMarketingPeriodMethod_detail("subscriptions.sms.marketing.method_detail"),
         @Json(name = "subscriptions.sms.marketing.last_updated") subscriptionsPeriodSmsPeriodMarketingPeriodLast_updated("subscriptions.sms.marketing.last_updated"),
         @Json(name = "subscriptions.mobile_push") subscriptionsPeriodMobile_push("subscriptions.mobile_push"),
         @Json(name = "subscriptions.mobile_push.marketing") subscriptionsPeriodMobile_pushPeriodMarketing("subscriptions.mobile_push.marketing"),
         @Json(name = "subscriptions.mobile_push.marketing.can_receive_push_marketing") subscriptionsPeriodMobile_pushPeriodMarketingPeriodCan_receive_push_marketing("subscriptions.mobile_push.marketing.can_receive_push_marketing"),
         @Json(name = "subscriptions.mobile_push.marketing.consent") subscriptionsPeriodMobile_pushPeriodMarketingPeriodConsent("subscriptions.mobile_push.marketing.consent"),
         @Json(name = "subscriptions.mobile_push.marketing.consent_timestamp") subscriptionsPeriodMobile_pushPeriodMarketingPeriodConsent_timestamp("subscriptions.mobile_push.marketing.consent_timestamp"),
         @Json(name = "predictive_analytics") predictive_analytics("predictive_analytics"),
         @Json(name = "predictive_analytics.historic_clv") predictive_analyticsPeriodHistoric_clv("predictive_analytics.historic_clv"),
         @Json(name = "predictive_analytics.predicted_clv") predictive_analyticsPeriodPredicted_clv("predictive_analytics.predicted_clv"),
         @Json(name = "predictive_analytics.total_clv") predictive_analyticsPeriodTotal_clv("predictive_analytics.total_clv"),
         @Json(name = "predictive_analytics.historic_number_of_orders") predictive_analyticsPeriodHistoric_number_of_orders("predictive_analytics.historic_number_of_orders"),
         @Json(name = "predictive_analytics.predicted_number_of_orders") predictive_analyticsPeriodPredicted_number_of_orders("predictive_analytics.predicted_number_of_orders"),
         @Json(name = "predictive_analytics.average_days_between_orders") predictive_analyticsPeriodAverage_days_between_orders("predictive_analytics.average_days_between_orders"),
         @Json(name = "predictive_analytics.average_order_value") predictive_analyticsPeriodAverage_order_value("predictive_analytics.average_order_value"),
         @Json(name = "predictive_analytics.churn_probability") predictive_analyticsPeriodChurn_probability("predictive_analytics.churn_probability"),
         @Json(name = "predictive_analytics.expected_date_of_next_order") predictive_analyticsPeriodExpected_date_of_next_order("predictive_analytics.expected_date_of_next_order");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Event Profile
     * Get the profile associated with an event with the given event ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60; &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return GetProfileResponseCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEventProfile(id: kotlin.String, revision: kotlin.String = "2024-07-15", additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetEventProfile>? = null, fieldsProfile: kotlin.collections.List<FieldsProfileGetEventProfile>? = null) : GetProfileResponseCollection {
        val localVarResponse = getEventProfileWithHttpInfo(id = id, revision = revision, additionalFieldsProfile = additionalFieldsProfile, fieldsProfile = fieldsProfile)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetProfileResponseCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Event Profile
     * Get the profile associated with an event with the given event ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60; &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return ApiResponse<GetProfileResponseCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventProfileWithHttpInfo(id: kotlin.String, revision: kotlin.String, additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetEventProfile>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetEventProfile>?) : ApiResponse<GetProfileResponseCollection?> {
        val localVariableConfig = getEventProfileRequestConfig(id = id, revision = revision, additionalFieldsProfile = additionalFieldsProfile, fieldsProfile = fieldsProfile)

        return request<Unit, GetProfileResponseCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEventProfile
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param additionalFieldsProfile Request additional fields not included by default in the response. Supported values: &#39;subscriptions&#39;, &#39;predictive_analytics&#39; (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @return RequestConfig
     */
    fun getEventProfileRequestConfig(id: kotlin.String, revision: kotlin.String, additionalFieldsProfile: kotlin.collections.List<AdditionalFieldsProfileGetEventProfile>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetEventProfile>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (additionalFieldsProfile != null) {
                    put("additional-fields[profile]", toMultiValue(additionalFieldsProfile.toList(), "csv"))
                }
                if (fieldsProfile != null) {
                    put("fields[profile]", toMultiValue(fieldsProfile.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/events/{id}/profile/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Event Relationships Metric
     * Get a list of related Metrics for an Event&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60; &#x60;metrics:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return GetEventMetricsRelationshipListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEventRelationshipsMetric(id: kotlin.String, revision: kotlin.String = "2024-07-15") : GetEventMetricsRelationshipListResponse {
        val localVarResponse = getEventRelationshipsMetricWithHttpInfo(id = id, revision = revision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEventMetricsRelationshipListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Event Relationships Metric
     * Get a list of related Metrics for an Event&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60; &#x60;metrics:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return ApiResponse<GetEventMetricsRelationshipListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventRelationshipsMetricWithHttpInfo(id: kotlin.String, revision: kotlin.String) : ApiResponse<GetEventMetricsRelationshipListResponse?> {
        val localVariableConfig = getEventRelationshipsMetricRequestConfig(id = id, revision = revision)

        return request<Unit, GetEventMetricsRelationshipListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEventRelationshipsMetric
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return RequestConfig
     */
    fun getEventRelationshipsMetricRequestConfig(id: kotlin.String, revision: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/events/{id}/relationships/metric/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Event Relationships Profile
     * Get profile [relationships](https://developers.klaviyo.com/en/reference/api_overview#relationships) for an event with the given event ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60; &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return GetEventProfilesRelationshipListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEventRelationshipsProfile(id: kotlin.String, revision: kotlin.String = "2024-07-15") : GetEventProfilesRelationshipListResponse {
        val localVarResponse = getEventRelationshipsProfileWithHttpInfo(id = id, revision = revision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEventProfilesRelationshipListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Event Relationships Profile
     * Get profile [relationships](https://developers.klaviyo.com/en/reference/api_overview#relationships) for an event with the given event ID.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60; &#x60;profiles:read&#x60;
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return ApiResponse<GetEventProfilesRelationshipListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventRelationshipsProfileWithHttpInfo(id: kotlin.String, revision: kotlin.String) : ApiResponse<GetEventProfilesRelationshipListResponse?> {
        val localVariableConfig = getEventRelationshipsProfileRequestConfig(id = id, revision = revision)

        return request<Unit, GetEventProfilesRelationshipListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEventRelationshipsProfile
     *
     * @param id 
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @return RequestConfig
     */
    fun getEventRelationshipsProfileRequestConfig(id: kotlin.String, revision: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/events/{id}/relationships/profile/".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fieldsEvent
     */
     enum class FieldsEventGetEvents(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp"),
         @Json(name = "event_properties") event_properties("event_properties"),
         @Json(name = "datetime") datetime("datetime"),
         @Json(name = "uuid") uuid("uuid");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsMetric
     */
     enum class FieldsMetricGetEvents(val value: kotlin.String) {
         @Json(name = "name") name("name"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "integration") integration("integration");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fieldsProfile
     */
     enum class FieldsProfileGetEvents(val value: kotlin.String) {
         @Json(name = "email") email("email"),
         @Json(name = "phone_number") phone_number("phone_number"),
         @Json(name = "external_id") external_id("external_id"),
         @Json(name = "first_name") first_name("first_name"),
         @Json(name = "last_name") last_name("last_name"),
         @Json(name = "organization") organization("organization"),
         @Json(name = "locale") locale("locale"),
         @Json(name = "title") title("title"),
         @Json(name = "image") image("image"),
         @Json(name = "created") created("created"),
         @Json(name = "updated") updated("updated"),
         @Json(name = "last_event_date") last_event_date("last_event_date"),
         @Json(name = "location") location("location"),
         @Json(name = "location.address1") locationPeriodAddress1("location.address1"),
         @Json(name = "location.address2") locationPeriodAddress2("location.address2"),
         @Json(name = "location.city") locationPeriodCity("location.city"),
         @Json(name = "location.country") locationPeriodCountry("location.country"),
         @Json(name = "location.latitude") locationPeriodLatitude("location.latitude"),
         @Json(name = "location.longitude") locationPeriodLongitude("location.longitude"),
         @Json(name = "location.region") locationPeriodRegion("location.region"),
         @Json(name = "location.zip") locationPeriodZip("location.zip"),
         @Json(name = "location.timezone") locationPeriodTimezone("location.timezone"),
         @Json(name = "location.ip") locationPeriodIp("location.ip"),
         @Json(name = "properties") properties("properties");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter include
     */
     enum class IncludeGetEvents(val value: kotlin.String) {
         @Json(name = "attributions") attributions("attributions"),
         @Json(name = "metric") metric("metric"),
         @Json(name = "profile") profile("profile");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetEvents(val value: kotlin.String) {
         @Json(name = "datetime") datetime("datetime"),
         @Json(name = "-datetime") MinusDatetime("-datetime"),
         @Json(name = "timestamp") timestamp("timestamp"),
         @Json(name = "-timestamp") MinusTimestamp("-timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get Events
     * Get all events in an account  Requests can be sorted by the following fields: &#x60;datetime&#x60;, &#x60;timestamp&#x60;  Returns a maximum of 200 events per page.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsEvent For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;metric_id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;profile_id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;profile&#x60;: &#x60;has&#x60;&lt;br&gt;&#x60;datetime&#x60;: &#x60;greater-or-equal&#x60;, &#x60;greater-than&#x60;, &#x60;less-or-equal&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;timestamp&#x60;: &#x60;greater-or-equal&#x60;, &#x60;greater-than&#x60;, &#x60;less-or-equal&#x60;, &#x60;less-than&#x60; (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return GetEventResponseCollectionCompoundDocument
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEvents(revision: kotlin.String = "2024-07-15", fieldsEvent: kotlin.collections.List<FieldsEventGetEvents>? = null, fieldsMetric: kotlin.collections.List<FieldsMetricGetEvents>? = null, fieldsProfile: kotlin.collections.List<FieldsProfileGetEvents>? = null, filter: kotlin.String? = null, include: kotlin.collections.List<IncludeGetEvents>? = null, pageCursor: kotlin.String? = null, sort: SortGetEvents? = null) : GetEventResponseCollectionCompoundDocument {
        val localVarResponse = getEventsWithHttpInfo(revision = revision, fieldsEvent = fieldsEvent, fieldsMetric = fieldsMetric, fieldsProfile = fieldsProfile, filter = filter, include = include, pageCursor = pageCursor, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEventResponseCollectionCompoundDocument
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Events
     * Get all events in an account  Requests can be sorted by the following fields: &#x60;datetime&#x60;, &#x60;timestamp&#x60;  Returns a maximum of 200 events per page.&lt;br&gt;&lt;br&gt;*Rate limits*:&lt;br&gt;Burst: &#x60;350/s&#x60;&lt;br&gt;Steady: &#x60;3500/m&#x60;  **Scopes:** &#x60;events:read&#x60;
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsEvent For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;metric_id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;profile_id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;profile&#x60;: &#x60;has&#x60;&lt;br&gt;&#x60;datetime&#x60;: &#x60;greater-or-equal&#x60;, &#x60;greater-than&#x60;, &#x60;less-or-equal&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;timestamp&#x60;: &#x60;greater-or-equal&#x60;, &#x60;greater-than&#x60;, &#x60;less-or-equal&#x60;, &#x60;less-than&#x60; (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return ApiResponse<GetEventResponseCollectionCompoundDocument?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventsWithHttpInfo(revision: kotlin.String, fieldsEvent: kotlin.collections.List<FieldsEventGetEvents>?, fieldsMetric: kotlin.collections.List<FieldsMetricGetEvents>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetEvents>?, filter: kotlin.String?, include: kotlin.collections.List<IncludeGetEvents>?, pageCursor: kotlin.String?, sort: SortGetEvents?) : ApiResponse<GetEventResponseCollectionCompoundDocument?> {
        val localVariableConfig = getEventsRequestConfig(revision = revision, fieldsEvent = fieldsEvent, fieldsMetric = fieldsMetric, fieldsProfile = fieldsProfile, filter = filter, include = include, pageCursor = pageCursor, sort = sort)

        return request<Unit, GetEventResponseCollectionCompoundDocument>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEvents
     *
     * @param revision API endpoint revision (format: YYYY-MM-DD[.suffix]) (default to "2024-07-15")
     * @param fieldsEvent For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsMetric For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param fieldsProfile For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sparse-fieldsets (optional)
     * @param filter For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#filtering&lt;br&gt;Allowed field(s)/operator(s):&lt;br&gt;&#x60;metric_id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;profile_id&#x60;: &#x60;equals&#x60;&lt;br&gt;&#x60;profile&#x60;: &#x60;has&#x60;&lt;br&gt;&#x60;datetime&#x60;: &#x60;greater-or-equal&#x60;, &#x60;greater-than&#x60;, &#x60;less-or-equal&#x60;, &#x60;less-than&#x60;&lt;br&gt;&#x60;timestamp&#x60;: &#x60;greater-or-equal&#x60;, &#x60;greater-than&#x60;, &#x60;less-or-equal&#x60;, &#x60;less-than&#x60; (optional)
     * @param include For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#relationships (optional)
     * @param pageCursor For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#pagination (optional)
     * @param sort For more information please visit https://developers.klaviyo.com/en/v2024-07-15/reference/api-overview#sorting (optional)
     * @return RequestConfig
     */
    fun getEventsRequestConfig(revision: kotlin.String, fieldsEvent: kotlin.collections.List<FieldsEventGetEvents>?, fieldsMetric: kotlin.collections.List<FieldsMetricGetEvents>?, fieldsProfile: kotlin.collections.List<FieldsProfileGetEvents>?, filter: kotlin.String?, include: kotlin.collections.List<IncludeGetEvents>?, pageCursor: kotlin.String?, sort: SortGetEvents?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fieldsEvent != null) {
                    put("fields[event]", toMultiValue(fieldsEvent.toList(), "csv"))
                }
                if (fieldsMetric != null) {
                    put("fields[metric]", toMultiValue(fieldsMetric.toList(), "csv"))
                }
                if (fieldsProfile != null) {
                    put("fields[profile]", toMultiValue(fieldsProfile.toList(), "csv"))
                }
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
                if (include != null) {
                    put("include", toMultiValue(include.toList(), "csv"))
                }
                if (pageCursor != null) {
                    put("page[cursor]", listOf(pageCursor.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        revision.apply { localVariableHeaders["revision"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/events/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
