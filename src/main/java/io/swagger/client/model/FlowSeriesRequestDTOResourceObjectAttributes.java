/*
 * Klaviyo API
 * The Klaviyo REST API. Please visit https://developers.klaviyo.com for more details.
 *
 * OpenAPI spec version: 2024-07-15
 * Contact: developers@klaviyo.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * FlowSeriesRequestDTOResourceObjectAttributes
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2024-09-18T16:09:09.130713678Z[GMT]")

public class FlowSeriesRequestDTOResourceObjectAttributes {
  /**
   * Defined reporting metric
   */
  @JsonAdapter(StatisticsEnum.Adapter.class)
  public enum StatisticsEnum {
    @SerializedName("average_order_value")
    AVERAGE_ORDER_VALUE("average_order_value"),
    @SerializedName("bounce_rate")
    BOUNCE_RATE("bounce_rate"),
    @SerializedName("bounced")
    BOUNCED("bounced"),
    @SerializedName("bounced_or_failed")
    BOUNCED_OR_FAILED("bounced_or_failed"),
    @SerializedName("bounced_or_failed_rate")
    BOUNCED_OR_FAILED_RATE("bounced_or_failed_rate"),
    @SerializedName("click_rate")
    CLICK_RATE("click_rate"),
    @SerializedName("click_to_open_rate")
    CLICK_TO_OPEN_RATE("click_to_open_rate"),
    @SerializedName("clicks")
    CLICKS("clicks"),
    @SerializedName("clicks_unique")
    CLICKS_UNIQUE("clicks_unique"),
    @SerializedName("conversion_rate")
    CONVERSION_RATE("conversion_rate"),
    @SerializedName("conversion_uniques")
    CONVERSION_UNIQUES("conversion_uniques"),
    @SerializedName("conversion_value")
    CONVERSION_VALUE("conversion_value"),
    @SerializedName("conversions")
    CONVERSIONS("conversions"),
    @SerializedName("delivered")
    DELIVERED("delivered"),
    @SerializedName("delivery_rate")
    DELIVERY_RATE("delivery_rate"),
    @SerializedName("failed")
    FAILED("failed"),
    @SerializedName("failed_rate")
    FAILED_RATE("failed_rate"),
    @SerializedName("open_rate")
    OPEN_RATE("open_rate"),
    @SerializedName("opens")
    OPENS("opens"),
    @SerializedName("opens_unique")
    OPENS_UNIQUE("opens_unique"),
    @SerializedName("recipients")
    RECIPIENTS("recipients"),
    @SerializedName("revenue_per_recipient")
    REVENUE_PER_RECIPIENT("revenue_per_recipient"),
    @SerializedName("spam_complaint_rate")
    SPAM_COMPLAINT_RATE("spam_complaint_rate"),
    @SerializedName("spam_complaints")
    SPAM_COMPLAINTS("spam_complaints"),
    @SerializedName("unsubscribe_rate")
    UNSUBSCRIBE_RATE("unsubscribe_rate"),
    @SerializedName("unsubscribe_uniques")
    UNSUBSCRIBE_UNIQUES("unsubscribe_uniques"),
    @SerializedName("unsubscribes")
    UNSUBSCRIBES("unsubscribes");

    private String value;

    StatisticsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StatisticsEnum fromValue(String input) {
      for (StatisticsEnum b : StatisticsEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StatisticsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatisticsEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public StatisticsEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return StatisticsEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("statistics")
  private List<StatisticsEnum> statistics = new ArrayList<StatisticsEnum>();

  @SerializedName("timeframe")
  private OneOfFlowSeriesRequestDTOResourceObjectAttributesTimeframe timeframe = null;

  /**
   * The interval used to aggregate data within the series request. If hourly is used, the timeframe cannot be longer than 7 days. If daily is used, the timeframe cannot be longer than 60 days. If monthly is used, the timeframe cannot be longer than 52 weeks.
   */
  @JsonAdapter(IntervalEnum.Adapter.class)
  public enum IntervalEnum {
    @SerializedName("daily")
    DAILY("daily"),
    @SerializedName("hourly")
    HOURLY("hourly"),
    @SerializedName("monthly")
    MONTHLY("monthly"),
    @SerializedName("weekly")
    WEEKLY("weekly");

    private String value;

    IntervalEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static IntervalEnum fromValue(String input) {
      for (IntervalEnum b : IntervalEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<IntervalEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IntervalEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public IntervalEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return IntervalEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("interval")
  private IntervalEnum interval = null;

  @SerializedName("conversion_metric_id")
  private String conversionMetricId = null;

  @SerializedName("filter")
  private String filter = null;

  public FlowSeriesRequestDTOResourceObjectAttributes statistics(List<StatisticsEnum> statistics) {
    this.statistics = statistics;
    return this;
  }

  public FlowSeriesRequestDTOResourceObjectAttributes addStatisticsItem(StatisticsEnum statisticsItem) {
    this.statistics.add(statisticsItem);
    return this;
  }

   /**
   * List of statistics to query for. All rate statistics will be returned in fractional form [0.0, 1.0]
   * @return statistics
  **/
  @Schema(example = "[\"opens\",\"open_rate\"]", required = true, description = "List of statistics to query for. All rate statistics will be returned in fractional form [0.0, 1.0]")
  public List<StatisticsEnum> getStatistics() {
    return statistics;
  }

  public void setStatistics(List<StatisticsEnum> statistics) {
    this.statistics = statistics;
  }

  public FlowSeriesRequestDTOResourceObjectAttributes timeframe(OneOfFlowSeriesRequestDTOResourceObjectAttributesTimeframe timeframe) {
    this.timeframe = timeframe;
    return this;
  }

   /**
   * The timeframe to query for data within. The max length a timeframe can be is 1 year
   * @return timeframe
  **/
  @Schema(required = true, description = "The timeframe to query for data within. The max length a timeframe can be is 1 year")
  public OneOfFlowSeriesRequestDTOResourceObjectAttributesTimeframe getTimeframe() {
    return timeframe;
  }

  public void setTimeframe(OneOfFlowSeriesRequestDTOResourceObjectAttributesTimeframe timeframe) {
    this.timeframe = timeframe;
  }

  public FlowSeriesRequestDTOResourceObjectAttributes interval(IntervalEnum interval) {
    this.interval = interval;
    return this;
  }

   /**
   * The interval used to aggregate data within the series request. If hourly is used, the timeframe cannot be longer than 7 days. If daily is used, the timeframe cannot be longer than 60 days. If monthly is used, the timeframe cannot be longer than 52 weeks.
   * @return interval
  **/
  @Schema(example = "weekly", required = true, description = "The interval used to aggregate data within the series request. If hourly is used, the timeframe cannot be longer than 7 days. If daily is used, the timeframe cannot be longer than 60 days. If monthly is used, the timeframe cannot be longer than 52 weeks.")
  public IntervalEnum getInterval() {
    return interval;
  }

  public void setInterval(IntervalEnum interval) {
    this.interval = interval;
  }

  public FlowSeriesRequestDTOResourceObjectAttributes conversionMetricId(String conversionMetricId) {
    this.conversionMetricId = conversionMetricId;
    return this;
  }

   /**
   * ID of the metric to be used for conversion statistics
   * @return conversionMetricId
  **/
  @Schema(example = "RESQ6t", required = true, description = "ID of the metric to be used for conversion statistics")
  public String getConversionMetricId() {
    return conversionMetricId;
  }

  public void setConversionMetricId(String conversionMetricId) {
    this.conversionMetricId = conversionMetricId;
  }

  public FlowSeriesRequestDTOResourceObjectAttributes filter(String filter) {
    this.filter = filter;
    return this;
  }

   /**
   * API filter string used to filter the query. Allowed filters are flow_id, send_channel, flow_message_id. Allowed operators are equals, contains-any. Only one filter can be used per attribute, only AND can be used as a combination operator. Max of 100 messages per ANY filter. When filtering on send_channel, allowed values are email, push-notification, sms.
   * @return filter
  **/
  @Schema(example = "and(equals(flow_id,\"abc123\"),contains-any(send_channel,[\"email\",\"sms\"]))", description = "API filter string used to filter the query. Allowed filters are flow_id, send_channel, flow_message_id. Allowed operators are equals, contains-any. Only one filter can be used per attribute, only AND can be used as a combination operator. Max of 100 messages per ANY filter. When filtering on send_channel, allowed values are email, push-notification, sms.")
  public String getFilter() {
    return filter;
  }

  public void setFilter(String filter) {
    this.filter = filter;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FlowSeriesRequestDTOResourceObjectAttributes flowSeriesRequestDTOResourceObjectAttributes = (FlowSeriesRequestDTOResourceObjectAttributes) o;
    return Objects.equals(this.statistics, flowSeriesRequestDTOResourceObjectAttributes.statistics) &&
        Objects.equals(this.timeframe, flowSeriesRequestDTOResourceObjectAttributes.timeframe) &&
        Objects.equals(this.interval, flowSeriesRequestDTOResourceObjectAttributes.interval) &&
        Objects.equals(this.conversionMetricId, flowSeriesRequestDTOResourceObjectAttributes.conversionMetricId) &&
        Objects.equals(this.filter, flowSeriesRequestDTOResourceObjectAttributes.filter);
  }

  @Override
  public int hashCode() {
    return Objects.hash(statistics, timeframe, interval, conversionMetricId, filter);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FlowSeriesRequestDTOResourceObjectAttributes {\n");
    
    sb.append("    statistics: ").append(toIndentedString(statistics)).append("\n");
    sb.append("    timeframe: ").append(toIndentedString(timeframe)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    conversionMetricId: ").append(toIndentedString(conversionMetricId)).append("\n");
    sb.append("    filter: ").append(toIndentedString(filter)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
